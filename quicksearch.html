<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"audit.js.html":{"id":"audit.js.html","title":"Source: audit.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: audit.js 'use strict'; const { Writable: WritableStream } = require('stream'); const assert = require('assert'); const crypto = require('crypto'); const constants = require('./constants'); const MerkleTree = require('mtree'); const utils = require('./utils'); /** * Represents a streaming audit challenge generator */ class Audit extends WritableStream { /** * @constructor * @param {number} audits - Total number of challenges to generate */ constructor(audits) { super(); assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); this.on('finish', this._generateTree.bind(this)); } /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ getPublicRecord() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1) .map((i) =&gt; i.toString('hex')); } /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ getPrivateRecord() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges.map((i) =&gt; i.toString('hex')) }; } /** * Implements the underlying write method * @private */ _write(bytes, encoding, next) { this._inputs.forEach((input, i) =&gt; { if (i &lt; this._audits) { input.update(bytes); } }); next(); } /** * Prepares the challenge hasher instances * @private */ _prepareChallenges() { let iterations = 0; let inputs = []; while (iterations &lt; this._audits) { const challenge = this._generateChallenge(); const input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return inputs; } /** * Generate the audit merkle tree from a series of challenges * @private */ _generateTree() { this._finished = true; this._tree = new MerkleTree(this._inputs.map((input, i) =&gt; { if (i &gt;= this._audits) { return input; } else { return utils.rmd160sha256(utils.rmd160(input.digest())); } }), utils.rmd160sha256); } /** * Generate a random challenge buffer * @private * @returns {buffer} */ _generateChallenge() { return crypto.randomBytes(constants.AUDIT_BYTES); } /** * Create a challenge response input to merkle tree * @private */ _createResponseInput(challenge) { return crypto.createHash('sha256').update(challenge); } /** * Returns a new instance from the predefined challenges and tree * @param {array} challenges - The precomputed challenges * @param {array} tree - The bottom leaves of the existing merkle tree * @returns {Audit} */ static fromRecords(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); tree = tree.map((i) =&gt; Buffer.from(i, 'hex')); const auditor = new Audit(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256); auditor._finished = true; return auditor; } } module.exports = Audit; × Search results Close "},"database.js.html":{"id":"database.js.html","title":"Source: database.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: database.js 'use strict'; const ms = require('ms'); const { Readable: ReadableStream } = require('stream'); const { EventEmitter } = require('events'); const mongoose = require('mongoose'); const { Schema, createConnection } = mongoose; const utils = require('./utils'); const secp256k1 = require('secp256k1'); const { utils: keyutils } = require('kad-spartacus'); const crypto = require('crypto'); const stringify = require('json-stable-stringify'); mongoose.Promise = Promise; /** * Describes a known network peer * @type {object} */ const PeerProfile = new Schema({ identity: { type: String, required: true, unique: true, min: 20, max: 20 }, contact: { hostname: { type: String, required: true }, port: { type: Number, required: true }, protocol: { type: String, required: true, default: 'https:' }, xpub: { type: String, required: true }, index: { type: Number, required: true, default: 0 }, agent: { type: String, default: 'unknown' } }, capacity: { allocated: { type: Number, default: 0 }, available: { type: Number, default: 0 }, timestamp: { type: Date, default: Date.now } }, reputation: { score: { type: Number, default: 0, min: 0 }, timestamp: { type: Date, default: Date.now } }, updated: { type: Date, default: Date.now }, _reports: { missed: { type: Number, default: 0 }, streak: { type: Number, default: 0 } } }); PeerProfile.set('toObject', { transform: function(doc, ret) { delete ret._id; delete ret.__v; delete ret._reports; } }); PeerProfile.methods.toString = function() { return [ this.contact.protocol, '//', this.contact.hostname, ':', this.contact.port ].join(''); }; /** * Describes the result of an audit as a report to directories * @type {object} */ const AuditReport = new Schema({ reporter: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') }, provider: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') }, challenge: { type: String, required: true }, expected: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') }, actual: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') } }); AuditReport.virtual('outcome').get(function() { return this.expected === this.actual ? 1 : 0; }); AuditReport.methods.toCompressedAuthenticated = function(privateKey) { let compressed, { signature, recovery } = secp256k1.sign( utils.sha256(Buffer.from(this.getSigningArray().join(''), 'hex')), privateKey ); signature = Buffer.concat([Buffer.from([recovery]), signature]); compressed = this.getSigningArray(); compressed.push(signature.toString('base64')); return compressed; }; AuditReport.methods.getSigningArray = function() { return [ this.reporter, this.provider, this.challenge, this.expected, this.actual ]; }; AuditReport.statics.verifyCompressedAuthenticated = function(compressed) { const report = new this({ reporter: compressed[0], provider: compressed[1], challenge: compressed[2], expected: compressed[3], actual: compressed[4] }); if (report.validateSync()) { return false; } const compactSig = Buffer.from(compressed[5], 'base64'); const recovery = compactSig[0]; const signature = compactSig.slice(1); const message = utils.sha256(Buffer.from( report.getSigningArray().join(''), 'hex' )); const pubkey = secp256k1.recover(message, signature, recovery, true); const pubkeyhash = report.reporter; return secp256k1.verify(message, signature, pubkey) &amp;&amp; keyutils.toPublicKeyHash(pubkey).toString('hex') === pubkeyhash; }; /** * Describes a contract between two peers for shard storage * @type {object} */ const ShardContract = new Schema({ version: { type: Number, required: true, default: 2 }, ownerParentKey: { type: String, required: true, match: new RegExp('^[1-9a-km-zA-HJ-NP-Z]{1,111}$') }, ownerIndex: { type: Number, required: true, default: 0, min: 0, max: 2147483647 }, ownerIdentity: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') }, ownerSignature: { type: String }, providerParentKey: { type: String, required: true, match: new RegExp('^[1-9a-km-zA-HJ-NP-Z]{1,111}$') }, providerIndex: { type: Number, required: true, default: 0, min: 0, max: 2147483647 }, providerIdentity: { type: String, required: true, match: new RegExp('[A-Fa-f0-9]{40}$') }, providerSignature: { type: String }, shardSize: { type: Number, required: true, min: 0 }, shardHash: { type: String, required: true, match: new RegExp('^[0-9a-f]{40}$') }, auditLeaves: [{ type: String, match: new RegExp('[A-Fa-f0-9]$') }], auditInterval: { type: Number, required: true, default: ms('60H') }, accessPolicies: [{ type: String }], fundingDestination: { type: String, default: 'none' }, _lastAuditTimestamp: { type: Date, default: Date.now }, _lastFundingTimestamp: { type: Date, default: Date.now }, _lastAccessTimestamp: { type: Date, default: Date.now } }); ShardContract.index({ shardHash: 1, providerIdentity: 1, ownerIdentity: 1 }); ShardContract.set('toObject', { virtuals: false, transform: function(doc, ret) { delete ret._lastAuditTimestamp; delete ret._lastAccessTimestamp; delete ret._lastFundingTimestamp; delete ret._id; delete ret.__v; } }); ShardContract.methods.getSigningString = function() { const obj = this.toObject(); delete obj.ownerSignature; delete obj.providerSignature; return JSON.stringify(obj); }; ShardContract.methods.signExternal = function(secret) { const { signature, recovery } = secp256k1.sign( utils.sha256(Buffer.from(this.getSigningString())), secret ); return Buffer.concat([Buffer.from([recovery]), signature]); }; ShardContract.methods.verifyExternal = function(signature, pubkey) { return secp256k1.verify( utils.sha256(Buffer.from(this.getSigningString())), signature, pubkey ); }; ShardContract.methods.verify = function(actor) { const compactSig = Buffer.from(this[`${actor}Signature`], 'base64'); const recovery = compactSig[0]; const signature = compactSig.slice(1); const message = utils.sha256(Buffer.from(this.getSigningString())); const pubkey = secp256k1.recover(message, signature, recovery, true); const pubkeyhash = this[`${actor}Identity`]; return this.verifyExternal(signature, pubkey) &amp;&amp; keyutils.toPublicKeyHash(pubkey).toString('hex') === pubkeyhash; }; ShardContract.methods.sign = function(actor, secret) { return this[`${actor}Signature`] = this.signExternal(secret) .toString('base64'); }; ShardContract.statics.diff = function(c1, c2) { const differs = []; c1 = c1.toObject(); c2 = c2.toObject(); for (let prop in c1) { if (Array.isArray(c1[prop])) { if (JSON.stringify(c1[prop]) !== JSON.stringify(c2[prop])) { differs.push(prop); } } else if (c1[prop] !== c2[prop]) { differs.push(prop); } } return differs; }; ShardContract.TYPE_GROUP = 'G'; ShardContract.TYPE_USER = 'U'; ShardContract.methods.checkAccessPolicy = function(contact) { let [identity, info] = contact; let allowed = []; if (this.ownerIdentity === identity || this.ownerParentKey === info.xpub) { return ['CONSIGN', 'RETRIEVE', 'RENEW', 'AUDIT', 'MIRROR']; } for (let p = 0; p &lt; this.accessPolicies.length; p++) { let policy = this.accessPolicies[p].split(':'); let [type, key, permissions] = policy; if (!type &amp;&amp; !key) { allowed = allowed.concat(permissions.split(',')); } if (type === ShardContract.TYPE_GROUP &amp;&amp; key === info.xpub) { allowed = allowed.concat(permissions.split(',')); } if (type === ShardContract.TYPE_USER &amp;&amp; key === identity) { allowed = allowed.concat(permissions.split(',')); } } return allowed; }; /** * Keeps references to the location of shards that compose an object * @type {object} */ const ObjectPointer = new Schema({ name: { type: String, default: 'untitled.blob' }, encoding: { type: String }, mimetype: { type: String, default: 'application/octet-stream' }, hash: { type: String, required: true, min: 64, max: 64 }, size: { type: Number, required: true }, status: { type: String, required: true, enum: ['finished', 'queued', 'failed'] }, shards: [{ size: { type: Number, required: true, min: 1 }, hash: { type: String, required: true }, service: [Schema.Types.Mixed], decayed: { type: Boolean, default: false }, audits: { root: { type: String }, challenges: [{ type: String }], depth: { type: Number } } }], ecpub: { type: String, min: 64, max: 66 }, ecprv: { type: String, min: 64, max: 64 }, policies: [{ type: String }], _lastAuditTimestamp: { type: Date, default: Date.now }, _isOwner: { type: Boolean, default: true } }); ObjectPointer.index({ uuid: 1 }); ObjectPointer.set('toObject', { transform: (doc, ret) =&gt; { delete ret._id; delete ret.__v; delete ret._lastAuditTimestamp; delete ret._isOwner; delete ret.ecprv; ret.id = doc._id; ret.shards = doc.shards.map(s =&gt; { return { size: s.size, hash: s.hash, service: s.service }; }); } }); ObjectPointer.virtual('percentDecayed').get(function() { let total = this.shards.length; let decayed = this.shards.filter(s =&gt; s.decayed).length; return decayed / total; }); ObjectPointer.methods.toEncryptedBlob = function() { const password = utils.rmd160sha256(stringify(this.toObject())); const cipher = crypto.createCipher('aes256', password); let blob = Buffer.concat([ cipher.update(stringify(this.toObject()), 'utf8'), cipher.final() ]); const hash = utils.rmd160(blob); const magnet = `magnet:?xt=urn:orc:${hash.toString('hex')}` + `&amp;xs=${this.size}` + `&amp;dn=${this.name}` + `&amp;x.ecprv=${this.ecprv}` + `&amp;x.pword=${password.toString('hex')}`; return { blob, hash, magnet }; }; /** * Some arbitrary blob of data stored in the DHT * @type {object} */ const NetworkBlob = new Schema({ key: { type: String, required: true, unique: true }, value: { type: String, required: true }, publisher: { type: String, required: true }, timestamp: { type: Date, required: true, default: Date.now } }); NetworkBlob.index({ key: 1 }); NetworkBlob.set('toObject', { transform: (doc, ret) =&gt; { delete ret._id; delete ret.__v; delete ret.key; } }); /** * Wraps a MongoDB connection and initializes models */ class Database extends EventEmitter { static get schemas() { return { PeerProfile, ShardContract, AuditReport, ObjectPointer, NetworkBlob }; } /** * @constructor * @param {string} connectionUri * @param {object} options */ constructor(uri) { super(); this.connection = createConnection.call(mongoose, uri, { useMongoClient: true }); this.connection.on('error', (err) =&gt; this.emit('error', err)); this.connection.on('open', () =&gt; this.emit('open')); for (let name in Database.schemas) { this[name] = this.connection.model(name, Database.schemas[name]); } } } /** * Wraps the supplied model for a kad/levelup compatible interface */ class KadStorageAdapter { /** * @constructor * @param {object} databaseModel */ constructor(model, keyName = 'key') { this.model = model; this.keyName = keyName; } /** * Get item by key * @param {string} key * @param {object} [options] * @param {function} callback */ get(key, options, callback) { /* istanbul ignore else */ if (typeof options === 'function') { callback = options; options = {}; } this.model.findOne({ [this.keyName]: key }, (err, doc) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } /* istanbul ignore if */ if (!doc) { return callback(new Error('Not found')); } callback(null, doc.toObject()); }); } /** * Put item by key * @param {string} key * @param {object} value * @param {object} [options] * @param {function} callback */ put(key, value, options, callback) { /* istanbul ignore else */ if (typeof options === 'function') { callback = options; options = {}; } this.model.findOneAndUpdate({ [this.keyName]: key }, value, { upsert: true }, callback); } /** * Delete item by key * @param {string} key * @param {function} callback */ del(key, callback) { this.model.remove({ [this.keyName]: key }, callback); } /** * Returns a readable stream of all items * @returns {ReadableStream} */ createReadStream() { const rs = new ReadableStream({ read: () =&gt; null, objectMode: true }); const cursor = this.model.find({}).cursor(); cursor .on('data', (doc) =&gt; { rs.push({ key: doc.key, value: doc.toObject() }) }) .on('error', (err) =&gt; { /* istanbul ignore next */ rs.emit('error', err); }) .on('end', () =&gt; rs.push(null)); return rs; } } module.exports = Database; module.exports.KadStorageAdapter = KadStorageAdapter; × Search results Close "},"bridge.js.html":{"id":"bridge.js.html","title":"Source: bridge.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: bridge.js 'use strict'; const constants = require('./constants'); const { Readable: ReadableStream } = require('stream'); const { EventEmitter } = require('events'); const BusBoy = require('busboy'); const ReedSolomon = require('@ronomon/reed-solomon'); const https = require('https'); const http = require('http'); const ws = require('ws'); const utils = require('./utils'); const fs = require('fs'); const merge = require('merge'); const express = require('express'); const auth = require('basic-auth'); const crypto = require('crypto'); const { tmpdir } = require('os'); const path = require('path'); const mkdirp = require('mkdirp'); const uuid = require('uuid'); const AuditStream = require('./audit'); const Proof = require('./proof'); const { knuthShuffle } = require('knuth-shuffle'); const stream = require('stream'); const async = require('async'); const ms = require('ms'); const rimraf = require('rimraf'); const { slice } = require('stream-slice'); const BUFFER = require('buffer'); const bytes = require('bytes'); const querystring = require('querystring'); const cors = require('cors'); const url = require('url'); const { utils: keyutils } = require('kad-spartacus'); const concat = require('concat-stream'); const qs = require('querystring'); /** * Represents a local HTTP(s) server that abstracts the upload and download * of files away to a simple request. Files are encrypted to the given public * key, split into shards for erasure codes. Prepped for distribution and * queued for storing in the network. Bridge exposes a simple API for getting * status of transfers and previously stored objects. * * GET / (List objects as JSON - or serve Web GUI) * GET /{hash} (Download object) * DELETE /{hash} (Delete object) * POST / (Upload object - Multipart) * * If auth is enabled, then the websocket control bridge expects: * ?auth={base64(user:pass)} as the query string */ class Bridge extends EventEmitter { static get DEFAULTS() { return { auth: { user: null, pass: null }, stage: path.join( tmpdir(), `staging.${crypto.randomBytes(16).toString('hex')}` ), enableSSL: false, serviceKeyPath: null, certificatePath: null, authorityChains: [], control: null }; } /** * @constructor * @param {Node} node * @param {object} options */ constructor(node, options) { super(); this.options = merge(Bridge.DEFAULTS, options); this.api = express(); this.node = node; this.database = this.node.database; this.server = this._createServer(this.api); this.control = this.options.control; this.wss = new ws.Server({ server: this.server, verifyClient: (info, cb) =&gt; this._verifyClient(info, cb) }); /* istanbul ignore else */ if (!fs.existsSync(this.options.stage)) { mkdirp.sync(this.options.stage); } this.server.setTimeout(0); this._bindRoutes(); setInterval(() =&gt; this.audit(), constants.AUDIT_INTERVAL); } /** * @private */ _createServer(handler) { let server = null; /* istanbul ignore if */ if (this.options.enableSSL) { server = https.createServer({ key: fs.readFileSync(this.options.serviceKeyPath), cert: fs.readFileSync(this.options.certificatePath), ca: this.options.authorityChains ? this.options.authorityChains.map(fs.readFileSync) : [] }, handler); } else { server = http.createServer(handler); } return server; } /** * @private */ _verifyClient(info, callback) { const { user, pass } = this.options.auth; const { query } = url.parse(info.req.url); let creds = querystring.parse(query).auth; if (user &amp;&amp; pass) { if (!creds) { return callback(false, 401, 'No credentials supplied'); } creds = Buffer.from(creds, 'base64').toString('utf8').split(':'); if (!(creds[0] === user &amp;&amp; creds[1] === pass)) { return callback(false, 401, 'Invalid credentials'); } } callback(true); } /** * Listens on the given port and hostname * @param {number} port * @param {string} hostname * @param {function} callback */ listen() { this.server.listen(...arguments); this.wss.on('connection', (sock) =&gt; { let client = new stream.Duplex({ read: () =&gt; null, write: (data, enc, cb) =&gt; sock.send(data, cb) }); this.control.client(client); sock.on('message', (data) =&gt; client.push(data)); sock.on('error', (err) =&gt; client.emit('error', err)); sock.on('close', () =&gt; client.emit('close')); }); } /** * Creates request router and handler stack * @private * @returns {function} */ _bindRoutes() { this.api.use(cors()) this.api.use(this.authenticate.bind(this)); this.api.get('/', this.list.bind(this)); this.api.get('/:id', this.download.bind(this)); this.api.get('/:id/magnet', this.magnet.bind(this)); this.api.post('/', this.upload.bind(this)); this.api.put('/', this.resolve.bind(this)); this.api.delete('/:id', this.destroy.bind(this)); this.api.use(this.error.bind(this)); } /** * Handles request authentication if defined * @param {object} request * @param {object} response * @param {function} next */ authenticate(req, res, next) { const { user, pass } = this.options.auth; const error = new Error('Not authorized'); error.code = 401; if (user &amp;&amp; pass) { const creds = auth(req); if (!creds || !(creds.name === user &amp;&amp; creds.pass === pass)) { res.setHeader('WWW-Authenticate', 'Basic realm=&quot;ORC&quot;'); return next(error); } } next(); } /** * Responds to requests with error code and message * @param {error} error * @param {object} request * @param {object} response * @param {function} next */ error(err, req, res, next) { if (!err) { return next(); } res.writeHead(err.code || 500); res.write(err.message); res.end(); } /** * Scans the object database and returns all index entries * @param {object} request * @param {object} response * @param {function} next */ list(req, res) { this.database.ObjectPointer.find({}, (err, pointers) =&gt; { /* istanbul ignore if */ if (err) { res.status(500).send(err.message); } else { res.status(200).send(pointers.map((o) =&gt; o.toObject())); } }); } /** * Queues the object for upload to the network * @param {object} request * @param {object} response * @param {function} next */ upload(req, res, next) { const busboy = new BusBoy({ headers: req.headers }); const objects = []; const policies = []; const id = uuid.v4(); busboy.on('field', (name, value) =&gt; { if (name === 'policy') { policies.push(value); } }); /* eslint max-params: [2, 5] */ busboy.once('file', (field, file, name, encoding, mime) =&gt; { const tmp = path.join(this.options.stage, id); mkdirp.sync(tmp); let size = 0; const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { size += data.length; hash.update(data); cb(null, data); } }); const {publicKey: ecpub, privateKey: ecprv} = keyutils.toHDKeyFromSeed(); const writer = fs.createWriteStream(path.join(tmp, 'ciphertext')); const cipher = utils.createCipher(ecpub, ecprv); objects.push({ name, encoding, mimetype: mime }); file.pipe(hasher).pipe(cipher).pipe(writer).on('finish', () =&gt; { const digest = hash.digest('hex'); const ciphertext = path.join(tmp, 'ciphertext'); const object = new this.database.ObjectPointer({ name, encoding, size, policies, ecpub: ecpub.toString('hex'), ecprv: ecprv.toString('hex'), mimetype: mime, hash: digest, shards: [], status: 'queued' }); /* istanbul ignore if */ if (size &gt; BUFFER.kMaxLength) { fs.unlink(path.join(tmp, 'ciphertext'), () =&gt; { return next(new Error( `File size exceeds max supported (${bytes(BUFFER.kMaxLength)})` )); }); } object.save(() =&gt; { this.distribute(ciphertext, object, (err, object) =&gt; { if (err) { return next(err); } res.status(201).send(object.toObject()); }); }); }); }); req.pipe(busboy); } /** * Takes the supplied file path and applies erasure codes, then attempts to * distribute the shards across the network * @param {string} filepath - Path to the file to distribute * @param {object} metadata * @param {ObjectPointer} object * @param {function} callback * @returns {EventEmitter} */ distribute(filepath, object, callback) { const stat = fs.statSync(filepath); const rsparams = utils.getErasureParameters(stat.size); const rs = new ReedSolomon(rsparams.shards, rsparams.parity); const encodeErasure = (callback) =&gt; { fs.readFile(filepath, (err, file) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } let parity = []; let { size } = rsparams; for (let i = 0; i &lt; rsparams.parity; i++) { parity.push(Buffer.alloc(rsparams.size)); } file = Buffer.concat([file, Buffer.concat(parity)]); rs.encode(file, 0, file.length, size, 0, size, (err) =&gt; { /* istanbul ignore if */ if (err) { callback(err); } else { callback(null, file, rsparams, object); } }); }); } const prepareShards = (file, rsparams, object, callback) =&gt; { let shards = []; let position = 0; const prepareContracts = () =&gt; { async.eachSeries(shards, (shard, next) =&gt; { const audit = new AuditStream(constants.NUM_CHALLENGES); const readStream = fs.createReadStream(shard.path); const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { hash.update(data); cb(null, data); } }); readStream.pipe(hasher).pipe(audit).on('finish', () =&gt; { shard.audits = audit.getPrivateRecord(); shard.audits.root = shard.audits.root.toString('hex') shard.proposal = new this.database.ShardContract({ shardHash: utils.rmd160(hash.digest()).toString('hex'), shardSize: rsparams.size, auditLeaves: audit.getPublicRecord(), ownerParentKey: this.node.contact.xpub, ownerIndex: this.node.contact.index, ownerIdentity: this.node.identity.toString('hex'), accessPolicies: object.policies }); shard.proposal.sign('owner', this.node.spartacus.privateKey); next(); }); }, () =&gt; { object.shards = shards; object.save(() =&gt; callback(null, shards, object)); }); } async.timesLimit(rsparams.shards + rsparams.parity, 1, (n, done) =&gt; { const pad = (n) =&gt; n &gt;= 10 ? n.toString() : `0${n}`; const shardpath = path.join(path.dirname(filepath), `${pad(n)}.shard`); const bufferSlice = file.slice(position, position + rsparams.size); fs.writeFile(shardpath, bufferSlice, () =&gt; { position += rsparams.size; shards.push({ index: n, size: rsparams.size, path: shardpath }); done(); }); }, () =&gt; { fs.unlink(filepath, () =&gt; prepareContracts()); }); }; const uploadShards = (shards, object, callback) =&gt; { async.eachLimit(shards, 3, (shard, next) =&gt; { async.retry({ times: 5 }, (done) =&gt; { this._pluckStorageProvider(shard.size, (err, target) =&gt; { if (err) { return done(err); } let proposal = shard.proposal; let rs = fs.createReadStream(shard.path); this.node.logger.info(`uploading shard to ${target[0]}`); this._createUploadChannel({ stream: rs, target, proposal, shard }, done); }); }, next); }, (err) =&gt; { object.shards = shards; if (err) { object.status = 'failed'; this.node.logger.error(err.message); object.save(() =&gt; callback(err)); } else { object.status = 'finished'; this.node.logger.info(`successfully uploaded ${object.hash}`); this.node.logger.info(`removing stage ${path.dirname(filepath)}`); rimraf(path.dirname(filepath), (err) =&gt; { /* istanbul ignore if */ if (err) { this.node.logger.error(err.message); } object.save(() =&gt; callback(null, object)); }); } }); } const distributePointer = (object, callback) =&gt; { const { blob, hash } = object.toEncryptedBlob(); const key = hash.toString('hex'); const encoded = blob.toString('base64'); this.node.iterativeStore(key, encoded, (err, stored) =&gt; { if (stored &lt; 3) { this.node.logger.warn( `failed to fully distribute pointer (${stored} of 3)` ); } callback(null, object); }); }; async.waterfall([ (next) =&gt; encodeErasure(next), (file, rs, obj, next) =&gt; prepareShards(file, rs, obj, next), (shards, obj, next) =&gt; uploadShards(shards, obj, next), (object, next) =&gt; distributePointer(object, next) ], callback); } /** * Downloads the object from the network * @param {object} request * @param {object} response * @param {function} next */ download(req, res, next) { this._downloadObject(req.params.id, (err, buffer, object, info) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } const { rsparams } = info; const decipher = utils.createDecipher( Buffer.from(object.ecpub, 'hex'), Buffer.from(object.ecprv, 'hex') ); decipher.on('error', (err) =&gt; { this.node.logger.error(err.message); res.end(); }); res.writeHead(200, { 'Content-Type': object.mimetype, 'Content-Length': object.size, 'Transfer-Encoding': '' }); decipher.pipe(slice(0, object.size - rsparams.padding)).pipe(res); decipher.end(buffer); }); } /** * @private * @param {string} id * @param {function} callback */ _downloadObject(id, next) { let targets = 0; let failed = []; let buffer = null; function updateRecovery(shard, i) { let recovery = { shard, offset: shard.size * i, length: (shard.size * i) + shard.size }; failed.push(recovery); buffer.fill(0, recovery.offset, recovery.length); targets |= (1 &lt;&lt; i); } const downloadShard = (shard, token, i, callback) =&gt; { let downloadStream = utils.createShardDownloader( shard.service, shard.hash, token, this.node.onion.createSecureAgent() ); let tmpBuffer = Buffer.from([]); downloadStream.on('error', (err) =&gt; { this.node.logger.warn( `failed to download, reason: ${err.message}` ); updateRecovery(shard, i); callback(); }); downloadStream.on('data', (data) =&gt; { tmpBuffer = Buffer.concat([tmpBuffer, data]); }); downloadStream.on('end', () =&gt; { buffer.fill(tmpBuffer, shard.size * i, (shard.size * i) + shard.size); callback(); }); }; const assembleShards = (object, size, rs, callback) =&gt; { let done = (err) =&gt; callback(err, buffer); try { rs.decode(buffer, 0, size, object.shards[0].size, 0, object.shards[0].size, targets, done); } catch (err) { /* istanbul ignore next */ callback(err); } }; this.database.ObjectPointer.findOne({ _id: id }, (err, object) =&gt; { /* istanbul ignore if */ if (err || !object) { return next(err || new Error('Not found')); } /* istanbul ignore if */ if (object.status !== 'finished') { return next(new Error( 'Cannot fetch object that did not complete upload' )); } let size = object.shards.reduce( (a, b) =&gt; ({ size: a.size + b.size }), { size: 0 } ).size; let rsparams = utils.getErasureParameters(size); let rs = new ReedSolomon(rsparams.shards, rsparams.parity); /* istanbul ignore if */ if (size &gt; BUFFER.kMaxLength) { return next(new Error( `File size exceeds max supported (${bytes(BUFFER.kMaxLength)})` )); } buffer = Buffer.alloc(size); async.eachOfLimit(object.shards, 3, (shard, i, done) =&gt; { this.node.authorizeRetrieval( shard.service, [shard.hash], (err, result) =&gt; { if (err) { this.node.logger.warn(err.message); updateRecovery(shard, i); return done(); } downloadShard(shard, result[0], i, done); } ); }, () =&gt; { assembleShards(object, size, rs, err =&gt; { /* istanbul ignore if */ if (err) { return next(err); } const decipher = utils.createDecipher( Buffer.from(object.ecpub, 'hex'), Buffer.from(object.ecprv, 'hex') ); decipher.on('error', (err) =&gt; { this.node.logger.error(err.message); }); decipher.pipe(slice(0, object.size - rsparams.padding)), decipher.end(buffer); next(null, buffer, object, { failed, rsparams } ); }); }); }); } /** * Ends contracts with farmers for the object parts and removes * reference to them * @param {object} request * @param {object} response * @param {function} next */ destroy(req, res, next) { let id = req.params.id; this.database.ObjectPointer.findOne({ _id: id }, (err, object) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } async.each(object.shards, (shard, done) =&gt; { this.database.ShardContract.remove({ shardHash: shard.hash }, (err) =&gt; { /* istanbul ignore if */ if (err) { this.node.logger.error( `failed to remove shard contract ${shard.hash}` ); } done(); }); }, () =&gt; { object.remove((err) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } res.status(201).send(); }) }); }); } /** * Returns the magnet link for the given object * @param {object} request * @param {object} response * @param {function} next */ magnet(req, res, next) { const { id } = req.params; this.database.ObjectPointer.findOne({ _id: id }, (err, object) =&gt; { /* istanbul ignore if */ if (err || !object) { return next(err || new Error('Object not found')); } const { magnet } = object.toEncryptedBlob(); res.status(200).json({ href: magnet }); }); } /** * Accepts a body containing a magnet link, resolves the pointer and creates * a local object pointer record, then returns it. Clients can follow with a * GET /:id to download the object * @param {object} request * @param {object} response * @param {function} next */ resolve(req, res, next) { req.on('error', next).pipe(concat((body) =&gt; { let parsed; try { parsed = qs.parse(url.parse(body.toString()).query); } catch (err) { /* istanbul ignore next */ return next(new Error('Failed to parse magnet link')); } this.node.iterativeFindValue( Buffer.from(parsed.xt.substr(8), 'hex').toString('hex'), (err, result) =&gt; { /* istanbul ignore if */ if (err || result.length &gt;= 0) { return next(err || new Error('Failed to resolve magnet')); } let item = result; let decipher = crypto.createDecipher( 'aes256', Buffer.from(parsed['x.pword'], 'hex') ); let cleartext = null; try { cleartext = Buffer.concat([ decipher.update(Buffer.from(item.value, 'base64')), decipher.final() ]).toString('utf8'); } catch (err) { return next(new Error('Failed to decrypt pointer')); } let object = new this.database.ObjectPointer(merge( JSON.parse(cleartext), { ecprv: parsed['x.ecprv'], _isOwner: false } )); object.save((err) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } res.status(200).json(object.toObject()); }); } ) })); } /** * Periodically call this to scan the object store for shards that need to * be audited * @param * @param {function} callback */ audit(callback = () =&gt; null) { const opportunities = constants.SCORE_INTERVAL / constants.AUDIT_INTERVAL; const query = { _lastAuditTimestamp: { $lt: Date.now() - constants.SCORE_INTERVAL }, _isOwner: true }; this.database.ObjectPointer.find(query, (err, objects) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } const total = Math.ceil(objects.length / opportunities); const candidates = []; while (candidates.length !== total) { candidates.push(knuthShuffle(objects).pop()); } async.eachSeries( candidates, (obj, next) =&gt; this._auditObject(obj, next), (err) =&gt; { /* istanbul ignore if */ if (err) { this.node.logger.warn(err.message); return callback(err); } this.emit('auditInternalFinished'); callback(); } ); }); } /** * @private */ _createUploadChannel({ stream, target, proposal, shard }, done) { this.node.claimFarmerCapacity(target, proposal, (err, data) =&gt; { if (err) { this.node.logger.warn( `failed to claim capacity, reason: ${err.message}` ); return done(err); } this.node.logger.info(`capacity claimed from ${target[0]}`); let [completedContract, consignToken] = data; let uploadStream = utils.createShardUploader( target, completedContract.shardHash, consignToken, this.node.onion.createSecureAgent() ); completedContract = new this.database.ShardContract( completedContract ); uploadStream.on('error', done); uploadStream.on('response', (res) =&gt; { let body = ''; res.on('data', (data) =&gt; body += data.toString()); res.on('end', () =&gt; { /* istanbul ignore if */ if (res.statusCode !== 200) { this.node.logger.warn( `failed to upload shard, reason: ${body}` ); return done(new Error(body)); } this.node.logger.debug(`shard uploaded to ${target[0]}`); delete shard.proposal; delete shard.path; shard.service = target; shard.hash = completedContract.shardHash; completedContract.save((err) =&gt; done(err)); }); }); stream.on('data', (data) =&gt; uploadStream.write(data)) .on('end', () =&gt; uploadStream.end()) .on('error', (err) =&gt; { /* istanbul ignore next */ uploadStream.removeAllListeners(); /* istanbul ignore next */ done(err); }); }); } /** * @private */ _auditObject(object, callback) { async.mapLimit(object.shards, 3, (shard, done) =&gt; { this.database.ShardContract.findOne({ shardHash: shard.hash }, (err, contract) =&gt; done(err, [shard, contract])); }, (err, results) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } async.eachLimit(results, 3, ([shard, contract], done) =&gt; { let challenge = shard.audits.challenges.shift(); let audits = [{ hash: shard.hash, challenge }]; let contact = this.node.router.getContactByNodeId( shard.service[0] ) || shard.service; contract._lastAuditTimestamp = Date.now(); this.node.auditRemoteShards(contact, audits, (err, proofs) =&gt; { const fail = (err, expected, actual) =&gt; { shard.decayed = true; const report = new this.database.AuditReport({ reporter: this.node.identity.toString('hex'), provider: contract.providerIdentity, challenge, expected, actual }); this.node.logger.warn(err.message); report.save(() =&gt; contract.save(() =&gt; done())); }; /* istanbul ignore if */ if (err) { return fail(err); } const pass = (report) =&gt; { report.save(() =&gt; contract.save(() =&gt; done())); }; let { proof } = proofs.pop() || { proof: [] }; let [expected, actual] = Proof.verify( proof, Buffer.from(shard.audits.root, 'hex'), shard.audits.depth ); if (Buffer.compare(expected, actual) !== 0) { return fail(new Error('Audit response failed verification'), expected.toString('hex'), actual.toString('hex')); } const report = new this.database.AuditReport({ reporter: this.node.identity.toString('hex'), provider: contract.providerIdentity, challenge, expected: expected.toString('hex'), actual: actual.toString('hex') }); if (shard.audits.challenges.length === 0) { this._regenerateChallenges(shard, () =&gt; pass(report)); } else { pass(report); } }); }, () =&gt; { object.save((err) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } /* istanbul ignore else */ if (object.percentDecayed &gt;= 0.25) { this.node.logger.info('object decay more than 25%, will rebuild'); this._rebuildObject(object, callback); } else { callback(); } }); }); }); } /** * @private */ _rebuildObject(object, callback = () =&gt; null) { this._downloadObject(object.id, (err, buffer, object, info) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } const rs = new ReadableStream({ read: function() { if (this.bufferDrained) { this.push(null); } else { this.bufferDrained = true; this.push(buffer); } } }); const { failed, rsparams } = info; async.eachLimit(failed, 3, (recovery, done) =&gt; { const { shard, offset, length } = recovery; const auditStream = new AuditStream(constants.NUM_CHALLENGES); const slice = buffer.slice(offset, length); auditStream.on('error', done).on('finish', () =&gt; { shard.audits = auditStream.getPrivateRecord(); shard.audits.root = shard.audits.root.toString('hex'); const proposal = new this.database.ShardContract({ shardHash: shard.hash, shardSize: rsparams.size, auditLeaves: auditStream.getPublicRecord(), ownerParentKey: this.node.contact.xpub, ownerIndex: this.node.contact.index, ownerIdentity: this.node.identity.toString('hex'), accessPolicies: object.policies }); this._pluckStorageProvider(shard.size, (err, target) =&gt; { /* istanbul ignore if */ if (err) { return done(err); } this.database.ShardContract.remove( { shardHash: shard.hash, ownerIdentity: { $not: { $eq: this.node.identity.toString('hex') } } }, () =&gt; this._createUploadChannel({ stream: rs, proposal: proposal.toObject(), target, shard }, done) ); }); }); auditStream.end(slice); }, () =&gt; object.save(callback)); }); } /** * @private * @param {number} size * @param {function} callback */ _pluckStorageProvider(size, callback) { this.database.PeerProfile.find({ 'capacity.timestamp': { $gt: Date.now() - ms('24HR') }, 'capacity.available': { $gt: size } }, (err, profiles) =&gt; { /* eslint max-statements: [2, 20] */ if (err) { this.node.logger.warn('failed to load capacity cache'); profiles = []; } let target = undefined; let contact = undefined; knuthShuffle(profiles); for (let i = 0; i &lt; profiles.length; i++) { contact = this.node.router.getContactByNodeId( profiles[i].identity ); target = contact ? [profiles[i].identity, contact] : [profiles[i].identity, profiles[i].contact]; /* istanbul ignore else */ if (target !== undefined) { break; } } if (target === undefined) { this.node.logger.warn( 'not enough capacity data collected to upload' ); callback(new Error('Not enough capacity information')); } else { callback(null, target); } }); } /** * @private */ _regenerateChallenges(shard, callback = () =&gt; null) { const auditStream = new AuditStream(constants.NUM_CHALLENGES); this.node.authorizeRetrieval(shard.service, [shard.hash], (err, result) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } const downloadStream = utils.createShardDownloader( shard.service, shard.hash, result[0], this.node.onion.createSecureAgent() ); downloadStream.pipe(auditStream).on('finish', () =&gt; { shard.audits = auditStream.getPrivateRecord(); shard.audits.root = shard.audits.root.toString('hex') this.node.database.ShardContract.findOne({ shardHash: shard.hash }, (err, contract) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } contract.auditLeaves = auditStream.getPublicRecord(); contract.sign('owner', this.node.spartacus.privateKey); contract.save((err) =&gt; { /* istanbul ignore if */ if (err) { return callback(err); } this.node.requestContractRenewal(shard.service, contract.toObject(), callback); }); }); }).on('error', callback); }); } } module.exports = Bridge; × Search results Close "},"directory.js.html":{"id":"directory.js.html","title":"Source: directory.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: directory.js 'use strict'; const http = require('http'); const https = require('https'); const fs = require('fs'); const cors = require('cors'); const ms = require('ms'); const async = require('async'); const merge = require('merge'); const url = require('url'); const express = require('express'); /** * Serves a single endpoint for retreiving network statistics */ class Directory { /** * @constructor * @param {Node} node * @param {object} options * @param {boolean} options.enableSSL - Use SSL * @param {string} options.serviceKeyPath - Path to PEM private key * @param {string} options.certificatePath - Path to PEM certificate * @param {string[]} options.authorityChains - Path to PEM CA certificates * @param {string} options.bootstrapService - Address to bootstrap profiles */ constructor(node, options) { this.node = node; this.database = this.node.database; this.bootstrapService = options.bootstrapService; this.app = express(); this.app.use(cors()); this.app.get('/', this._handleGetOnlineProfiles.bind(this)); this.app.get('/:identity', this._handleGetProfile.bind(this)); /* istanbul ignore if */ if (options.enableSSL) { this.server = https.createServer({ key: fs.readFileSync(options.serviceKeyPath), cert: fs.readFileSync(options.certificatePath), ca: options.authorityChains ? options.authorityChains.map(fs.readFileSync) : [] }, this.app); } else { this.server = http.createServer(this.app); } } /** * Bootstraps the peer profiles * @param {function} callback */ bootstrap(callback) { let opts = merge(url.parse(this.bootstrapService), { agent: this.node.onion.createSecureAgent() }); let proto = opts.protocol === 'https:' ? https : http; proto.get(opts, (res) =&gt; { let body = ''; res.on('data', (d) =&gt; body += d.toString()).on('end', () =&gt; { try { body = JSON.parse(body); } catch (err) { /* istanbul ignore next */ return callback('Failed to parse directory payload'); } async.eachSeries(body, (profile, next) =&gt; { this.database.PeerProfile.findOneAndUpdate( { identity: profile.identity }, profile, { upsert: true }, next ); }, callback); }).on('error', callback); }).on('error', callback); } /** * @private */ _handleGetOnlineProfiles(req, res, next) { let now = Date.now(); this.database.PeerProfile.find({ $or: [ { 'capacity.timestamp': { $gt: now - ms('24HR') } }, { updated: { $gt: now - ms('24HR') } } ] }, [], { sort: { 'capacity.timestamp': -1 } }, (err, results) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } res.writeHead(200, { 'Content-Type': 'application/json' }); res.end(JSON.stringify(results.map((r) =&gt; r.toObject()))); }); } /** * @private */ _handleGetProfile(req, res, next) { this.database.PeerProfile.findOne({ identity: req.params.identity }, (err, profile) =&gt; { /* istanbul ignore if */ if (err) { return next(err); } if (!profile) { res.writeHead(404); res.end('Profile not known'); } else { res.writeHead(200, { 'Content-Type': 'application/json' }); res.end(JSON.stringify(profile.toObject())); } }); } /** * Start the server on the supplied port and hostname * @param {number} port * @param {string} hostname * @param {function} callback */ listen() { this.server.listen(...arguments); } /** * Takes all audit reports and reaps them while applying their results to * local peer profile reputation score, then publishes the compressed * payload to the bootstrap directory * @param {function} callback */ scoreAndPublishAuditReports(callback = () =&gt; null) { const payload = []; const profiles = new Set(); const cursor = this.database.AuditReport.find({}).cursor(); const worker = (report, done) =&gt; { const { reporter, provider } = report; payload.push(report.toCompressedAuthenticated( this.node.spartacus.privateKey )); this.database.PeerProfile.count({ identity: { $in: [reporter, provider] } }, (err, count) =&gt; { /* istanbul ignore if */ if (count !== 2) { this.node.logger.warn( 'skipping score application for unknown peer(s)' ); return done(); } profiles.add(reporter); profiles.add(provider); this._applyScore(report, () =&gt; done()); }); }; const queue = async.queue(worker, 1); queue.drain = () =&gt; { this.node.reportAuditResults(payload, (err) =&gt; { /* istanbul ignore if */ if (err) { this.node.logger.warn(err.message); } async.series([ // NB: Keep track of reporting streaks (done) =&gt; { this.database.PeerProfile.update({ identity: { $in: [...profiles] } }, { $inc: { '_reports.streak': 1 }, $set: { '_reports.missed': 0 } }, done); }, // NB: Keep track of missed reports (done) =&gt; { this.database.PeerProfile.update({ identity: { $not: { $in: [...profiles] } } }, { $set: { '_reports.streak': 0 }, $inc: { '_reports.missed': 1 } }, done); }, // NB: Apply reward for 10+ streak (done) =&gt; { this.database.PeerProfile.update({ '_reports.streak': { $gte: 10 } }, { $inc: { 'reputation.score': 6 } }, done); }, // NB: Apply penalty for 2+ missed (done) =&gt; { this.database.PeerProfile.update({ '_reports.missed': { $gt: 2 }, }, { $inc: { 'reputation.score': -3 } }, done); }, // NB: Rebalance any negative scores (done) =&gt; { this.database.PeerProfile.update({ 'reputation.score': { $lt: 0 } }, { $set: { 'reputation.score': 0 } }, done); } ], callback); }); }; cursor.on('data', (report) =&gt; queue.push(report)).on('error', callback); } /** * @private */ _applyScore(auditReport, callback) { async.series([ // NB: Reporter loses 1 per report (done) =&gt; { this.database.PeerProfile.findOneAndUpdate({ identity: auditReport.reporter }, { $inc: { 'reputation.score': -1 } }, done); }, // NB: Reporter gains 1 per positive report (done) =&gt; { if (auditReport.expected === auditReport.actual) { this.database.PeerProfile.findOneAndUpdate({ identity: auditReport.reporter }, { $inc: { 'reputation.score': 1 } }, done); } else { done(); } }, // NB: Reporter gains 1 if another peer reports the same outcome (done) =&gt; { this.database.AuditReport.findOne({ provider: auditReport.provider, reporter: { $not: { $eq: auditReport.reporter } } }, (err, corroboratedReport) =&gt; { if (err || !corroboratedReport) { done(); } else if (auditReport.outcome === corroboratedReport.outcome) { this.database.PeerProfile.findOneAndUpdate({ identity: auditReport.reporter }, { $inc: { 'reputation.score': 1 } }, done); } else { done(); } }); }, // NB: Reporter gains 1 if the provider reported on them too (done) =&gt; { this.database.AuditReport.findOne({ reporter: auditReport.provider, provider: auditReport.reporter }, (err, mutualReport) =&gt; { if (mutualReport) { this.database.PeerProfile.findOneAndUpdate({ identity: auditReport.reporter }, { $inc: { 'reputation.score': 1 } }, done); } else { done(); } }); } ], () =&gt; callback()); } } module.exports = Directory; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: index.js /** * @module orc * @license AGPL-3.0 */ 'use strict'; const { fork } = require('child_process'); const { join } = require('path'); /** * Forks a child orc process and returns the child process and a controller * client for sending commands to it * @function * @param {object|string} config - Configuration properties as object or path * to a configuration file. See {@tutorial config} for details. * connect to the control port * @returns {object} */ /* istanbul ignore next */ module.exports = function(config = {}) { /* eslint max-statements: [2, 20] */ const defaults = require('../bin/config'); const cport = config.ControlPort || defaults.ControlPort; const caddr = config.ControlHostname || defaults.ControlHostname; const controller = new module.exports.control.Client(); let envs = {}; let file = join(__dirname, '../bin/orcd.js'); let args = []; let trys = 10; let opts = { env: envs, execPath: process.execPath, stdio: ['pipe', 'pipe', 'pipe', 'ipc'] }; if (typeof config === 'string') { args = args.concat(['--config', config]); } else { for (let prop in config) { envs[`orc_${prop}`] = config[prop]; } } const child = fork(file, args, opts); function connect() { function handleError() { controller.removeAllListeners(); if (trys !== 0) { trys--; setTimeout(connect, 1000); } } controller .once('error', handleError) .once('ready', () =&gt; controller.removeListener('error', handleError)) .connect(cport, caddr); } process.on('exit', () =&gt; child.kill()); child.stdout.once('data', () =&gt; setTimeout(() =&gt; connect(), 1000)); child.stderr.once('data', (msg) =&gt; child.emit('error', new Error(msg))); return { child, controller }; }; /** {@link Node} */ module.exports.Node = require('./node'); /** {@link Rules} */ module.exports.Rules = require('./rules'); /** {@link Transport} */ module.exports.Transport = require('./transport'); /** {@link Server} */ module.exports.Server = require('./server'); /** {@link Audit} */ module.exports.Audit = require('./audit'); /** {@link Proof} */ module.exports.Proof = require('./proof'); /** {@link Shards} */ module.exports.Shards = require('./shards'); /** {@link Bridge} */ module.exports.Bridge = require('./bridge'); /** {@link Directory} */ module.exports.Directory = require('./directory'); /** {@link Database} */ module.exports.Database = require('./database'); /** {@link module:orc/constants} */ module.exports.constants = require('./constants'); /** {@link module:orc/utils} */ module.exports.utils = require('./utils'); /** {@link module:orc/version} */ module.exports.version = require('./version'); /** @see https://github.com/bookchin/boscar */ module.exports.control = require('boscar'); × Search results Close "},"constants.js.html":{"id":"constants.js.html","title":"Source: constants.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: constants.js /** * @module orc/constants */ 'use strict'; module.exports = { /** * @constant {number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** * @constant {number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 86400000, /** * @constant {number} CONSIGN_THRESHOLD - Threshold for consign time */ CONSIGN_THRESHOLD: 86400000, /** * @constant {number} TOKEN_EXPIRE - Reject data token after time */ TOKEN_EXPIRE: 1800000, /** * @constant {number }MAX_NODE_INDEX - Maximum node index */ MAX_NODE_INDEX: 0x7fffffff, /** * @constant {string} HD_KEY_DERIVATION_PATH - Key derivation path for HD key */ HD_KEY_DERIVATION_PATH: 'm/3000\\'/0\\'', /** * @constant {number} AUDIT_INTERVAL - Time interval for audit check */ AUDIT_INTERVAL: 21600000, /** * @constant {number} SCORE_INTERVAL - Time to score for reputation */ SCORE_INTERVAL: 259200000, /** * @constant {number} REAPER_GRACE - Grace period beyond score interval */ REAPER_GRACE: 172800000, /** * @constant {number} NUM_CHALLENGES - Total challenges to generate per object */ NUM_CHALLENGES: 12 }; × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: utils.js /** * @module orc/utils */ 'use strict'; const https = require('https'); const stream = require('stream'); const assert = require('assert'); const secp256k1 = require('secp256k1'); const HDKey = require('hdkey'); const constants = require('./constants'); const crypto = require('crypto'); const semver = require('semver'); const ip = require('ip'); /** * Returns the SHA-256 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.sha256 = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160 = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160sha256 = function(input, encoding) { return module.exports.rmd160(module.exports.sha256(input, encoding)); }; /** * Returns the next power of two number * @param {number} number * @returns {number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Returns a stringified URL from the supplied contact object * @param {array} contact * @param {string} contact.0 - Node identity key * @param {object} contact.1 * @param {string} contact.1.hostname * @param {string} contact.1.port * @param {string} contact.1.protocol * @returns {string} */ module.exports.getContactURL = function(contact) { const [identity, info] = contact; return `${info.protocol}//${info.hostname}:${info.port}/${identity}`; }; /** * Returns whether or not the supplied semver tag is compatible * @param {string} version - The semver tag from the contact * @returns {boolean} */ module.exports.isCompatibleVersion = function(version) { const local = require('./version').protocol; const remote = version; const sameMajor = semver.major(local) === semver.major(remote); const diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {array} contact - The contact information for a given peer * @param {boolean} loopback - Allows contacts that are localhost * @returns {boolean} */ module.exports.isValidContact = function(contact, loopback) { const [, info] = contact; const isValidAddr = ip.isV4Format(info.hostname) || ip.isV6Format(info.hostname) || ip.isPublic(info.hostname); const isValidPort = info.port &gt; 0; const isAllowedAddr = ip.isLoopback(info.hostname) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Determines if a value is hexadecimal string * @param {*} a - The value to be tested * @returns {boolean} */ module.exports.isHexaString = function(a) { if (typeof a !== 'string') { return false; } return /^[0-9a-fA-F]+$/.test(a); }; /** * Checks if the supplied HD key is valid (base58 encoded) and proper length * @param {string} hdKey - The HD key in base 58 encoding * @returns {boolean} isValidHDKey */ module.exports.isValidHDNodeKey = function(hdKey) { return typeof hdKey === 'string' &amp;&amp; /^[1-9a-km-zA-HJ-NP-Z]{1,111}$/.test(hdKey); }; /** * Checks if the input is a non-hardened HD key index * @param {number} hdIndex - The HD key index * @returns {boolean} isValidHDKeyIndex */ module.exports.isValidNodeIndex = function(n) { return !Number.isNaN(n) &amp;&amp; (parseInt(n) === n) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= constants.MAX_NODE_INDEX; }; /** * Returns a HD key object using corrent key derivation path using the * given seed * @param {buffer} seed64 - 64 byte seed for generating key * @returns {HDKey} */ module.exports.createComplexKeyFromSeed = function(seed64) { assert(Buffer.isBuffer(seed64), 'Seed must be a buffer'); assert(seed64.length === 64, 'Seed must be 64 bytes in length'); var hdKey = HDKey.fromMasterSeed(seed64).derive( constants.HD_KEY_DERIVATION_PATH ); return hdKey.privateExtendedKey; }; /** * Returns a request object for uploading a shard to a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @param {Agent} [agent] * @returns {https.ClientRequest} */ module.exports.createShardUploader = function(farmer, hash, token, agent) { const [, contact] = farmer; function _createUploadStream() { return https.request({ method: 'POST', rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' }, agent: agent }); } return new stream.Transform({ transform: function(chunk, encoding, callback) { /* istanbul ignore else */ if (!this._uploader) { this._uploader = _createUploadStream(); this._uploader.on('response', this.emit.bind(this, 'response')); this._uploader.on('error', (err) =&gt; { this.unpipe(); this.emit('error', err); }); } this._uploader.write(chunk, encoding, callback); }, flush: function(callback) { /* istanbul ignore else */ if (this._uploader) { this._uploader.end(); } callback(); } }); }; /** * Returns a request object for downloading a shard from a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @param {Agent} [agent] * @returns {https.ClientRequest} */ module.exports.createShardDownloader = function(farmer, hash, token, agent) { const [, contact] = farmer; function _createDownloadStream() { return https.get({ rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' }, agent: agent }); } return new stream.Readable({ read: function() { if (!this._downloader) { this._downloader = _createDownloadStream(); this._downloader.on('response', (res) =&gt; { res .on('data', this.push.bind(this)) .on('error', this.emit.bind(this, 'error')) .on('end', this.push.bind(this, null)); }) .on('error', this.emit.bind(this, 'error')); } } }); }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createCipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const cipher = crypto.createCipher('aes-256-cbc', secret); return cipher; }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createDecipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const decipher = crypto.createDecipher('aes-256-cbc', secret); return decipher; }; /** * Returns the appropriate shard size, number of shards, and number of parity * shards for RS encoding/decoding provided the total number of bytes of the * complete content * @param {number} n - Number of bytes in data * @returns {object} */ module.exports.getErasureParameters = function(n) { let size = 8 * (1024 * 1024); let params = { shards: 2, parity: 1, get length() { return n + params.padding; }, get size() { return params.length / params.shards; }, padding: 0 }; function accumulate() { if (n &gt; size &amp;&amp; params.shards !== 16 &amp;&amp; params.parity !== 8) { size = size * 8; params.shards = params.shards * 2; params.parity = params.parity * 2; while (!Number.isSafeInteger(params.size)) { params.padding++; } return accumulate(); } else { return params; } } return accumulate(); }; × Search results Close "},"version.js.html":{"id":"version.js.html","title":"Source: version.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: version.js /** * @module orc/version */ 'use strict'; var semver = require('semver'); var assert = require('assert'); var postfix = process.env.ORC_NETWORK ? `-${process.env.ORC_NETWORK}` : ''; module.exports = { /** * @constant {string} protocol - The supported protocol version */ protocol: '3.0.0' + postfix, /** * @constant {string} software - The current software version */ software: require('../package').version, /** * Returns human readable string of versions * @function * @returns {string} */ toString: function() { let { software, protocol } = module.exports; return `orc v${software} protocol v${protocol}`; } }; assert( semver.valid(module.exports.protocol), 'Invalid protocol version specified' ); × Search results Close "},"node.js.html":{"id":"node.js.html","title":"Source: node.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: node.js 'use strict'; const url = require('url'); const { Readable: ReadableStream } = require('stream'); const { createLogger } = require('bunyan'); const merge = require('merge'); const kad = require('kad'); const quasar = require('kad-quasar'); const spartacus = require('kad-spartacus'); const cas = require('kad-content'); const constants = require('./constants'); const https = require('https'); const async = require('async'); const Rules = require('./rules'); const Server = require('./server'); const Transport = require('./transport'); const Database = require('./database'); /** * Extends Kademlia with Orc protocol rules * @license AGPL-3.0 */ class Node extends kad.KademliaNode { static get DEFAULTS() { return { logger: createLogger({ name: 'orc' }), transport: new Transport(), privateExtendedKey: null, keyDerivationIndex: 1 }; } /** * @constructor * @extends {KademliaNode} * @param {object} options * @param {string} options.privateExtendedKey - HD extended private key * @param {object} [options.logger] - Bunyan compatible logger * @param {Transport} [options.transport] * @param {Database} options.database * @param {Shards} options.shards * @param {number} [options.keyDerivationIndex] - HD derivation index */ constructor(options) { const opts = merge(Node.DEFAULTS, options, { storage: new Database.KadStorageAdapter(options.database.NetworkBlob) }); super(opts); this.quasar = this.plugin(quasar); this.spartacus = this.plugin(spartacus( options.privateExtendedKey, options.keyDerivationIndex, constants.HD_KEY_DERIVATION_PATH )); this.cas = this.plugin(cas({ keyAlgorithm: 'rmd160', valueEncoding: 'base64' })); this.database = opts.database; this.shards = opts.shards; this.server = new Server({ database: this.database, shards: this.shards, identity: this.identity }); this.transport.on('identify', (req, res) =&gt; { this.logger.debug('responding to peer requested identification'); res.end(JSON.stringify([ this.identity.toString('hex'), this.contact ])); }); this.transport.on('download', (req, res) =&gt; { this.logger.debug('handling shard download request'); this.server.download(req, res) }); this.transport.on('upload', (req, res) =&gt; { this.logger.debug('handling shard upload request'); this.server.upload(req, res) }); } /** * Adds the kademlia rule handlers before calling super#listen() */ listen() { let handlers = new Rules(this); this.use('AUDIT', handlers.audit.bind(handlers)); this.use('CONSIGN', handlers.consign.bind(handlers)); this.use('MIRROR', handlers.mirror.bind(handlers)); this.use('RETRIEVE', handlers.retrieve.bind(handlers)); this.use('RENEW', handlers.renew.bind(handlers)); this.use('CLAIM', handlers.claim.bind(handlers)); super.listen(...arguments); } /** * Sends a GET request to the URI and parses the result as a valid * contact object with identity * @param {string} url - The URL of the node * @param {Node~identifyServiceCallback} callback */ identifyService(uri, callback) { const options = merge(url.parse(uri), { agent: this.onion.createSecureAgent(), method: 'GET' }); const req = https.request(options, (res) =&gt; { let body = ''; res.on('error', callback); res.on('data', (data) =&gt; body += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { callback(new Error(body)); } else { try { callback(null, JSON.parse(body)); } catch (err) { callback(new Error('Failed to parse identity')); } } }); }); req.on('error', callback); req.end(); } /** * @callback Node~identifyServiceCallback * @param {error|null} error * @param {array} contact */ /** * Requests authorization tokens to pull file shard(s) from another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to pull * @param {Node~authorizeRetrievalCallback} callback */ authorizeRetrieval(peer, hashes, callback) { this.send('RETRIEVE', hashes, peer, callback); } /** * @callback Node~authorizeRetrievalCallback * @param {error|null} error * @param {string[]} retrievalTokens */ /** * Requests authorization tokens to push file shard(s) to another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to push * @param {Node~authorizeConsignmentCallback} callback */ authorizeConsignment(peer, hashes, callback) { this.send('CONSIGN', hashes, peer, callback); } /** * @callback Node~authorizeConsignmentCallback * @param {error|null} error * @param {string[]} consignmentTokens */ /** * Requests the source node to MIRROR a shard to the supplied destination * @param {array} source * @param {string} source.0 - Identity key string * @param {string|object} source.1 - Address data for contact * @param {object} target * @param {array} target.destination - * @param {string} target.destination.0 - Identity key string * @param {string|object} target.destination.1 - Address data for contact * @param {string} target.hash - Hash of the shard to mirror * @param {string} target.token - Authorization token to PUSH shard * @param {Node~createShardMirrorCallback} callback */ createShardMirror(source, target, callback) { this.send('MIRROR', [target.hash, target.token, target.destination], source, callback); } /** * @callback Node~createShardMirrorCallback * @param {object|null} error */ /** * Sends the series of hash/challenge pairs to the remote node to request * proof-of-storage * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object[]} audits * @param {string} audits.hash - Hash of the shard to prove * @param {string} audits.challenge - Challenge string to prepend to shard * @param {Node~auditRemoteShardsCallback} callback */ auditRemoteShards(peer, audits, callback) { this.send('AUDIT', audits, peer, callback); } /** * @callback Node~auditRemoteShardsCallback * @param {object|null} error * @param {object[]} proofs * @param {string} proofs.hash - Hash of the shard for corresponding proof * @param {string} proofs.proof - {@tutorial compact-merkle-proof} */ /** * Requests that the target peer update their local version of the given * contract. Used to extend storage time or terminate storage. Peer will * respond with an error or their updated, signed record of the renewal. * @param {array} peer * @param {string} peer.0 - Identity key string * @param {object} peer.1 - Address data for contact * @param {object} contract - The completed shard descriptor contract * @param {Node~requestContractRenewalCallback} callback */ requestContractRenewal(peer, descriptor, callback) { this.send('RENEW', [descriptor], peer, (err, result) =&gt; { if (err) { return callback(err); } const contract = new this.database.ShardContract(result[0]); if (!(!contract.validateSync() &amp;&amp; contract.verify('owner'))) { return callback(new Error( 'Peer replied with invalid or incomplete contract' )); } this.database.ShardContract.findOneAndUpdate({ shardHash: descriptor.shardHash }, result[0], (err) =&gt; callback(err, contract)); }); } /** * @callback Node~requestContractRenewalCallback * @param {error|null} error * @param {object} contract - See {@tutorial storage-contracts} */ /** * Subscribes to capacity announcements for the given topic codes * and exposes announcements as a stream. * @param {Node~subscribeCapacityAnnouncementCallback} callback */ subscribeCapacityAnnouncement(callback) { const capacityStream = new ReadableStream({ read: () =&gt; null, objectMode: true }); this.quasarSubscribe('ANNOUNCE', ([data, contact]) =&gt; { capacityStream.push([data, contact]); }); callback(null, capacityStream); } /** * @callback Node~subscribeCapacityAnnouncementCallback * @param {error|null} error * @param {ReadableStream} capacityStream */ /** * Announces to interested renter nodes that this node has capacity * available for renting. * @param {number} data * @param {number} data.available - Total bytes capacity available * @param {number} data.allocated - Total bytes capacity allocated * @param {Node~publishCapacityAnnouncementCallback} callback */ publishCapacityAnnouncement(data, callback) { const contents = [ data, [this.identity.toString('hex'), this.contact] ]; this.quasarPublish('ANNOUNCE', contents, callback); } /** * @callback Node~publishCapacityAnnouncementCallback * @param {error|null} error */ /** * Claims capacity from a farming node, given a valid contract * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object} descriptor - Contract descriptor * @param {Node~claimFarmerCapacityCallback} callback */ claimFarmerCapacity(peer, descriptor, callback) { this.send('CLAIM', [descriptor], peer, callback); } /** * @callback Node~claimFarmerCapacityCallback * @param {error|null} error * @param {array} result * @param {object} result.0 - Completed contract result * @param {string} result.1 - Consignment token */ /** * Publishes the supplied audit reports to nearest neighbors * @param {array[]} report * @param {Node~reportAuditResultsCallback} callback */ reportAuditResults(report, callback) { const peers = this.router.getClosestContactsToKey( this.identity, kad.constants.ALPHA ); async.each(peers, (peer, done) =&gt; { this.send('REPORT', report, peer, done); }, callback); } } module.exports = Node; × Search results Close "},"proof.js.html":{"id":"proof.js.html","title":"Source: proof.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: proof.js 'use strict'; const { Transform: TransformStream } = require('stream'); const assert = require('assert'); const MerkleTree = require('mtree'); const crypto = require('crypto'); const utils = require('./utils'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} */ class Proof extends TransformStream { /** * Verifies the proof given the merkle root and tree depth * @static * @memberof Proof * @param {*} proof - Compact proof result * @param {string} root - Merkle tree root from audit leaves * @param {number} depth - Depth of the merkle tree * @returns {string[]} */ static verify(proof, root, depth) { function _getChallengeResponse(tuple) { let data = tuple || proof; if (data.length === 1) { return utils.rmd160sha256(data[0], 'hex'); } if (Array.isArray(data[0])) { return _getChallengeResponse(data[0]); } else if (Array.isArray(data[1])) { return _getChallengeResponse(data[1]); } else { return Buffer.alloc(20, 0).toString('hex'); } } function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); const proofhash = utils.rmd160sha256(proof[0], 'hex'); assert(Buffer.compare(proofhash, leaf) === 0, 'Invalid proof value'); return leaf; } let hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0] || Buffer.alloc(20, 0).toString('hex'); } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1] || Buffer.alloc(20, 0).toString('hex'); } return utils.rmd160sha256(Buffer.concat([ Buffer.from(hashL, 'hex'), Buffer.from(hashR, 'hex') ])); } return [ _collapse(proof, _getChallengeResponse(), depth - 1), root ]; } /** * @constructor * @param {string[]} merkleLeaves - Bottom leaves of the audit merkle tree * @param {string|buffer} hexChallenge - The challenge data in hex to prepend * to shard */ constructor(leaves, challenge) { super({ objectMode: true }); assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256); if (!Buffer.isBuffer(challenge)) { this._challenge = Buffer.from(challenge, 'hex'); } else { this._challenge = challenge; } this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; } /** * Returns the generated proof structure * @return {array} */ getProofResult() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; } /** * Handles writing the shard data to the proof stream * @private */ _transform(chunk, encoding, next) { this._hasher.update(chunk, encoding); next(); } /** * Generates the proof from the read data * @private */ _flush(done) { try { this._generateProof(); } catch (err) { return done(err); } this.push(this.getProofResult()); done(); } /** * Returns the index of the associated audit leaf * @private */ _findMatchIndex(leaves, leaf) { let challengenum = -1; for (let l = 0; l &lt; leaves.length; l++) { if (Buffer.compare(leaves[l], leaf) === 0) { challengenum = l; break; } } return challengenum; } /** * Calculate audit response * @private * @param {string} challenge - Challenge string sent by auditor * @returns {string[]} result - Challenge response */ _generateProof() { const response = utils.rmd160(this._hasher.digest()); const leaves = this._tree.level(this._tree.levels() - 1); const leaf = utils.rmd160sha256(response); let challengenum = this._findMatchIndex(leaves, leaf); let branches = [response.toString('hex')]; assert(challengenum !== -1, 'Failed to generate proof'); for (let i = (this._tree.levels() - 1); i &gt; 0; i--) { let level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1].toString('hex')]; } else { branches = [level[challengenum - 1].toString('hex'), branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; } /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {string[]} leaves */ _generateLeaves(leaves) { const numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; const emptyLeaves = []; for (let i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.map((i) =&gt; Buffer.from(i, 'hex')).concat(emptyLeaves); } } module.exports = Proof; × Search results Close "},"rules.js.html":{"id":"rules.js.html","title":"Source: rules.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: rules.js 'use strict'; const { randomBytes } = require('crypto'); const async = require('async'); const utils = require('./utils'); const ProofStream = require('./proof'); /** * Represents Orc protocol handlers */ class Rules { /** * Constructs a Orc rules instance in the context of a Orc node * @constructor * @param {Node} node */ constructor(node) { this.node = node; } /** * Upon receipt of a AUDIT message, the node must look up the contract that * is associated with each hash-challenge pair in the payload, prepend the * challenge to the shard data, and caclulate the resulting hash, formatted * as a compact proof. See {@tutorial compact-proofs}. * @param {object} request * @param {object} response */ audit(request, response, next) { const audits = request.params; if (!Array.isArray(audits)) { return next(new Error('Invalid audit batch supplied')); } async.mapSeries(audits, ({ hash, challenge }, done) =&gt; { this.node.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return done(null, { hash, proof: null }); } if (!contract.checkAccessPolicy(request.contact).includes('AUDIT')) { return next(new Error('Not authorized')); } const auditLeaves = contract.auditLeaves; const proofStream = new ProofStream(auditLeaves, challenge); proofStream.on('error', () =&gt; { proofStream.removeAllListeners('finish'); done(null, { hash, proof: null }); }); proofStream.on('finish', () =&gt; { contract._lastAuditTimestamp = Date.now(); proofStream.removeAllListeners('error'); contract.save(() =&gt; { done(null, { hash, proof: proofStream.getProofResult() }); }); }); this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return done(null, { hash, proof: null }); } shardStream.pipe(proofStream); }); }); }, (err, proofs) =&gt; response.send(proofs)); } /** * Upon receipt of a CONSIGN message, the node must verify that it has a * valid storage allocation and contract for the supplied hash and identity * of the originator. If so, it must generate an authorization token which * will be checked by the shard server before accepting the transfer of the * associated shard. * @param {object} request * @param {object} response */ consign(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return next(err || new Error('Contract not found')); } if (!contract.checkAccessPolicy(request.contact).includes('CONSIGN')) { return next(new Error('Not authorized')); } const token = randomBytes(32).toString('hex'); this.node.server.accept(token, hash, contact); response.send([token]); }); } /** * Upon receipt of a MIRROR message, the node must verify that it is in * possesion of the shard on behalf of the identity or the message * originator. If so, given the token-hash pair, it must attempt to upload * it's copy of the shard to the target to establish a mirror. * @param {object} request * @param {object} response */ mirror(request, response, next) { const [hash, token, target] = request.params; this.node.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return next(err || new Error('Contract not found')); } this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return next(err); } const uploader = utils.createShardUploader(target, hash, token); uploader.on('response', (res) =&gt; { let result = ''; res.on('data', (data) =&gt; result += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { return next(new Error(result)); } response.send([result]); }); }); shardStream.pipe(uploader).once('error', next); }); }); } /** * Upon receipt of a RETRIEVE message, the node must verify that it is in * possession of the shard on behalf of the identity of the originator. * If so, it must generate an authorization token which will be checked by * the shard server before accepting the transfer of the associated shard. * @param {object} request * @param {object} response */ retrieve(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return next(err || new Error('Contract not found')); } const token = randomBytes(32).toString('hex'); this.node.shards.exists(hash, (err, exists) =&gt; { if (err || !exists) { return next(err || new Error('Shard not found')); } this.node.server.accept(token, hash, contact); response.send([token]); }); }); } /** * Upon receipt of a RENEW message, the recipient farmer must extend or * terminate it's contract based on the new terms supplied by the renter. * If the renewal descriptor is valid and complete, the farmer must store * the updated version after signing and respond back to the originator * with the version containing the updated signature. * @param {object} request * @param {object} response */ renew(request, response, next) { const [descriptor] = request.params; const renewal = new this.node.database.ShardContract(descriptor); const hash = renewal.shardHash; if (!(!renewal.validateSync() &amp;&amp; renewal.verify('owner'))) { return next(new Error('Descriptor is invalid or incomplete')); } this.node.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return next(err || new Error('Contract not found')); } const allowed = [ 'ownerIdentity', 'ownerParentKey', 'ownerSignature', 'ownerIndex', 'auditLeaves', 'accessPolicies' ]; const difference = this.node.database.ShardContract.diff( contract, renewal ); for (let prop of difference) { if (!allowed.includes(prop)) { return next(new Error(`Rejecting renewal of ${prop}`)); } } renewal.sign('provider', this.node.spartacus.privateKey); renewal.save((err) =&gt; { if (err) { return next(err); } response.send([renewal.toObject()]); }); }); } /** * Upon receipt of an `CLAIM` message, nodes must validate the descriptor, * then ensure that there is enough available space for the shard. If both * checks succeed, then the descriptor is signed and returned along with a * consignment token so the initiating renter can immediately upload the * data. These messages are generally sent based on information collected * when subscribed to farmer capacity publications. * @param {object} request * @param {object} response */ claim(request, response, next) { const [descriptor] = request.params; const contract = new this.node.database.ShardContract(descriptor); const hash = contract.shardHash; if (!contract.verify('owner')) { return next(new Error('Invalid shard descriptor')); } this.node.shards.size((err, result) =&gt; { if (err || (result.available &lt; contract.shardSize)) { return next(new Error('Not enough capacity available')); } contract.fundingDestination = null; contract.providerIdentity = this.node.identity.toString('hex'); contract.providerParentKey = this.node.contact.xpub; contract.providerIndex = this.node.contact.index; contract.sign('provider', this.node.spartacus.privateKey); if (contract.validateSync()) { return next(new Error('Invalid shard descriptor')); } contract.save((err) =&gt; { if (err) { return next(err); } const token = randomBytes(32).toString('hex'); this.node.server.accept(token, hash, request.contact); response.send([contract.toObject(), token]); }); }); } /** * Handles the receipt of a REPORT message containing audit results for N * total peers * @param {object} request * @param {object} response * @param {function} next */ report(request, response) { let reports = request.params .filter((compressed) =&gt; { return this.node.database.AuditReport .verifyCompressedAuthenticated(compressed); }) .map(([reporter, provider, challenge, expected, actual]) =&gt; { return new this.node.database.AuditReport({ reporter, provider, challenge, expected, actual }); }); async.filterLimit( reports, 6, (report, next) =&gt; report.save(err =&gt; next(null, err ? false : true)), (err, accepted) =&gt; response.send(accepted.map(a =&gt; a.challenge)) ); } } module.exports = Rules; × Search results Close "},"server.js.html":{"id":"server.js.html","title":"Source: server.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: server.js 'use strict'; const merge = require('merge'); const async = require('async'); const assert = require('assert'); const { EventEmitter } = require('events'); const crypto = require('crypto'); const utils = require('./utils'); /** * Creates a shard server for sending and receiving consigned file shards */ class Server extends EventEmitter { static get DEFAULTS() { return { tokenTtl: 1800000 }; }; /** * @constructor * @license AGPL-3.0 * @param {object} options * @param {string} options.identity - Node identity key * @param {Database} options.database * @param {Shards} options.shards * @param {number} [options.tokenTtl=1800000] - Expire unused token */ constructor(options) { super(); options = merge(Server.DEFAULTS, options); this.identity = options.identity; this.shards = options.shards; this.database = options.database; this._allowed = new Map(); this._ttl = options.tokenTtl; setInterval(() =&gt; this._reapExpiredTokens(), this._ttl); } /** * Triggered when a shard has finished uploading to this instance * @event Server#shardUploaded * @param {string} hash - The hash associated with the upload */ /** * Triggered when a shard has finished downloading from this instance * @event Server#shardDownloaded * @param {string} hash - The hash associated with the download */ /** * Triggered when a error occurs * @event Server#error * @param {error} error */ /** * Begin accepting data for the given file hash and token * @param {string} token - The authorization token created for transfer * @param {string} filehash - The shard hash to allow for the token * @param {array} contact - Contact that negotiated the token */ accept(token, filehash, contact) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed.set(token, { hash: filehash, contact: contact, expires: Date.now() + this._ttl }); } /** * Stop accepting data for the given token * @param {string} token - The authorization token created for transfer */ reject(token) { assert(typeof token === 'string', 'Invalid token supplied'); this._allowed.delete(token); } /** * Validates the given token * @param {string} token * @param {string} hash * @returns {object} */ authorize(token, hash) { assert.ok(token, 'You did not supply a token'); assert.ok(this._allowed.has(token), 'The token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(this._allowed.get(token).expires &gt; Date.now(), 'Token expired'); assert(this._allowed.get(token).hash === hash, 'Token not valid'); return this._allowed.get(token); } /** * Receives the data stream and writes it to storage * @param {http.IncomingMessage} req * @param {http.ServerResponse} req */ upload(req, res) { const hasher = crypto.createHash('sha256'); const { hash } = merge({}, this._allowed.get(req.query.token)); function respond(err, statusCode) { res.statusCode = statusCode; res.end(err ? err.message : ''); } let shardSize = 0; let receivedBytes = 0; async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { this.database.ShardContract.findOne({ shardHash: hash }, (err, contract) =&gt; { if (err || !contract) { return next(err || new Error('Not found'), 404); } shardSize = contract.shardSize; this.shards.createWriteStream(hash, (err, writeStream) =&gt; { if (err) { return next(err, 500); } next(null, writeStream, contract); }); }); }, (writeStream, contract, next) =&gt; { req.on('data', (chunk) =&gt; { receivedBytes += chunk.length; hasher.update(chunk); writeStream.write(chunk); if (receivedBytes &gt; shardSize) { this.shards.unlink(hash, () =&gt; null); next(new Error('Shard exceeds size defined in contract'), 400); } }); req.on('end', () =&gt; { if (utils.rmd160(hasher.digest()).toString('hex') !== hash) { this.shards.unlink(hash, () =&gt; null); return next(new Error('Hash does not match contract'), 400); } writeStream.end(); this.reject(req.query.token); this.emit('shardUploaded', contract); next(null, 200); }); } ], respond); } /** * Pumps the data through to the client * @param {http.IncomingMessage} req * @param {http.ServerResponse} res */ download(req, res) { function respond(err, statusCode) { res.statusCode = statusCode; res.end(err.message); } async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { const { hash } = this._allowed.get(req.query.token); this.shards.createReadStream(hash, (err, readStream) =&gt; { if (err) { return next(err, 404); } this.database.ShardContract.update({ shardHash: hash }, { $set: { _lastAccessTimestamp: Date.now() } }, () =&gt; { next(null, readStream, hash); }); }); }, (readStream, hash) =&gt; { res.setHeader('content-type', 'application/octet-stream'); readStream .on('error', (/* err */) =&gt; res.end()) .on('end', () =&gt; { this.emit('shardDownloaded', hash); this.reject(req.query.token); }) .pipe(res); } ], respond); } /** * Enumerates the authorized list and rejects expired * @private */ _reapExpiredTokens() { let now = Date.now(); for (let [token] of this._allowed) { if (this._allowed.get(token).expires &lt; now) { this.reject(token); } } } } module.exports = Server; × Search results Close "},"shards.js.html":{"id":"shards.js.html","title":"Source: shards.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: shards.js 'use strict'; const merge = require('merge'); const assert = require('assert'); const fs = require('fs'); const du = require('du'); const path = require('path'); /** * Convenience wrapper for storing shards scoped to a directory */ class Shards { static get DEFAULTS() { return { maxSpaceAllocated: 0 }; } /** * @constructor * @param {string} directory - Directory path to shard storage */ constructor(directory, options) { assert.ok(directory, 'Invalid directory supplied'); assert(fs.existsSync(directory), 'Supplied directory does not exist'); this.directory = directory; this.options = merge(Shards.DEFAULTS, options); } /** * Wraps read stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createReadStreamCallback} callback */ createReadStream(key, callback) { let rs = null; try { rs = fs.createReadStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, rs); } /** * @callback Shards~createReadStreamCallback * @param {error|null} error * @param {object} stream */ /** * Wraps write stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createWriteStreamCallback} callback */ createWriteStream(key, callback) { let ws = null; try { ws = fs.createWriteStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, ws); } /** * @callback Shards~createWriteStreamCallback * @param {error|null} error * @param {object} stream */ /** * Unlink the shard from the file system * @param {string} key * @param {Shards~unlinkCallback} callback */ unlink(key, callback) { fs.unlink(path.join(this.directory, key), callback); } /** * @callback Shards~unlinkCallback * @param {error|null} error */ /** * Check if the shard exists * @param {string} key * @param {Shards~existsCallback} callback */ exists(key, callback) { callback(null, fs.existsSync(path.join(this.directory, key))); } /** * @callback Shards~existsCallback * @param {error|null} error * @param {boolean} exists */ /** * Get used space and remaining allocation * @param {Shards~sizeCallback} callback */ size(callback) { du(this.directory, (err, used) =&gt; { if (err) { return callback(err); } const allocated = this.options.maxSpaceAllocated; callback(null, { allocated, available: used &gt;= allocated ? 0 : allocated - used }); }); } /** * @callback Shards~sizeCallback * @param {error|null} error * @param {object} size */ } module.exports = Shards; × Search results Close "},"transport.js.html":{"id":"transport.js.html","title":"Source: transport.js","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Source: transport.js 'use strict'; const url = require('url'); const merge = require('merge'); const connect = require('connect'); const { HTTPSTransport } = require('kad'); const { Agent } = require('https'); /** * Represents the Orc-specific HTTP(S) transport */ class Transport extends HTTPSTransport { /** * Emitted when a download request is received * @event Transport#download * @param {object} request * @param {object} response */ /** * Emitted when a upload request is received * @event Transport#upload * @param {object} request * @param {object} response */ /** * Contructs a Orc transport adapter * @constructor * @param {object} options * @see https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options */ constructor(options) { super(options); } /** * Make sure we explicity set the keepAlive options on requests * @private */ _createRequest(options) { const request = super._createRequest(merge({ agent: new Agent({ keepAlive: true, keepAliveMsecs: 25000 }), path: '/rpc/', rejectUnauthorized: false }, options)); request.setNoDelay(true); return request; } /** * Disable nagle algorithm on connections * @private */ _createServer(options) { const server = super._createServer(options); server.on('connection', (sock) =&gt; sock.setNoDelay(true)); return server; } /** * Handles requests by sending through middleware stack * @private */ _handle() { const middleware = connect(); middleware.use(Transport.CORS); middleware.use('/', (req, res, next) =&gt; { return req.url !== '/' ? next() : this.emit('identify', req, res); }); middleware.use('/rpc/', super._handle.bind(this)); middleware.use('/shards/', this._shards.bind(this)); middleware(...arguments); } /** * Handle routing request to shard server * @private */ _shards(req, res) { const urlobj = url.parse(req.originalUrl, true); const [, hash] = urlobj.pathname.split('/shards/'); req.query = urlobj.query; req.params = { hash }; if (req.method === 'POST') { this.emit('upload', req, res); } else if (req.method === 'GET') { this.emit('download', req, res); } else { res.statusCode = 405; res.end(); } } /** * Applies cross origin headers to responses * @static * @memberof Transport * @private */ static get CORS() { return function(req, res, next) { res.setHeader('access-control-allow-origin', '*'); res.setHeader('access-control-allow-methods', '*'); res.setHeader('access-control-allow-headers', '*'); if (req.method === 'OPTIONS') { res.statusCode = 200; res.end(); } else { next(); } } } } module.exports = Transport; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Global Members &lt;constant&gt; AuditReport :object Describes the result of an audit as a report to directories Type: object Source: database.js &lt;constant&gt; NetworkBlob :object Some arbitrary blob of data stored in the DHT Type: object Source: database.js &lt;constant&gt; ObjectPointer :object Keeps references to the location of shards that compose an object Type: object Source: database.js &lt;constant&gt; PeerProfile :object Describes a known network peer Type: object Source: database.js &lt;constant&gt; ShardContract :object Describes a contract between two peers for shard storage Type: object Source: database.js × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Modules Classes Audit Bridge Database Directory KadStorageAdapter Node Proof Rules Server Shards Transport Events error Triggered when a error occurs Parameters: Name Type Description error error Source: server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: transport.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Classes Classes Audit Bridge Database Directory KadStorageAdapter Node Proof Rules Server Shards Transport Events error Triggered when a error occurs Parameters: Name Type Description error error Source: server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: transport.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Tutorials Classes Audit Bridge Database Directory KadStorageAdapter Node Proof Rules Server Shards Transport Events error Triggered when a error occurs Parameters: Name Type Description error error Source: server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: transport.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract The Onion Routed Cloud. ORC is a distributed anonymous cloud storage network owned and operated by all of us. Join the discussion in #orc on our community chat! | | | | Desktop Installation (Recommended)Simply download a pre-built package for your platform from the releases page! Note! ORC uses the system Tor package on GNU/Linux, so you must install it yourself using your distribution's package manager. Server Installation (Advanced)Pull the image from Docker Hub. docker pull orcproject/orcCreate a data directory on the host. mkdir ~/.config/orcRun the ORC container and mount the data directory. docker run -v ~/.config/orc:/root/.config/orc -t orcproject/orc:latestModify the created configuration at ~/.config/orc/config as desired (see the Configuration Guide) and restart the container for the changes to take effect. Be sure to expose BridgePort and map it to the host if you want to use the API. docker run \\ --publish 127.0.0.1:4445:4445 \\ --volume ~/.config/orc:/root/.config/orc \\ --tty orcproject/orc:latest See the docker run documentation for more information. If you prefer to install ORC manually, see the guide for Manual Installation. Once installed, simply run orc with an optional configuration file using the --config &lt;path/to/config&gt; option. Once the container has started, you can navigate in your browser to http://127.0.0.1:4445 to access your node's dashboard! If you did not disable BridgeAuthenticationEnabled, you will be asked for supply the credentials in your configuration file. DevelopmentTo hack on the ORC project, clone this repository and use Docker Compose: git clone https://github.com/orcproject/orc cd orc docker-compose upThis will volume mount the the appropriate directories for development, and then boots up the ORC container. Note that stable releases are tagged and the master branch may contain unstable or bleeding-edge code. Alternatively, you can run directly on your host. Use npm install and npm link to install dependencies. Start the daemon with orcd or the desktop application with orc. Happy hacking! Resources Documentation Specification LicenseORC - Distributed Anonymous CloudCopyright (C) 2017 Counterpoint Hackerspace, Ltd. This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"Audit.html":{"id":"Audit.html","title":"Class: Audit","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Audit Audit Represents a streaming audit challenge generator new Audit(audits) Parameters: Name Type Description audits number Total number of challenges to generate Source: audit.js Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges array The precomputed challenges tree array The bottom leaves of the existing merkle tree Source: audit.js Returns: Type Audit getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: audit.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: audit.js Returns: leaves - Bottom merkle leaves of audit tree Type Array × Search results Close "},"Bridge.html":{"id":"Bridge.html","title":"Class: Bridge","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Bridge Bridge Represents a local HTTP(s) server that abstracts the upload and download of files away to a simple request. Files are encrypted to the given public key, split into shards for erasure codes. Prepped for distribution and queued for storing in the network. Bridge exposes a simple API for getting status of transfers and previously stored objects. GET / (List objects as JSON - or serve Web GUI) GET /{hash} (Download object) DELETE /{hash} (Delete object) POST / (Upload object - Multipart) If auth is enabled, then the websocket control bridge expects: ?auth={base64(user:pass)} as the query string new Bridge(node, options) Parameters: Name Type Description node Node options object Source: bridge.js Methods audit(callback, callback) Periodically call this to scan the object store for shards that need to be audited Parameters: Name Type Description callback callback function Source: bridge.js authenticate(request, response, next) Handles request authentication if defined Parameters: Name Type Description request object response object next function Source: bridge.js destroy(request, response, next) Ends contracts with farmers for the object parts and removes reference to them Parameters: Name Type Description request object response object next function Source: bridge.js distribute(filepath, metadata, object, callback) Takes the supplied file path and applies erasure codes, then attempts to distribute the shards across the network Parameters: Name Type Description filepath string Path to the file to distribute metadata object object ObjectPointer callback function Source: bridge.js Returns: Type EventEmitter download(request, response, next) Downloads the object from the network Parameters: Name Type Description request object response object next function Source: bridge.js error(error, request, response, next) Responds to requests with error code and message Parameters: Name Type Description error error request object response object next function Source: bridge.js list(request, response, next) Scans the object database and returns all index entries Parameters: Name Type Description request object response object next function Source: bridge.js listen(port, hostname, callback) Listens on the given port and hostname Parameters: Name Type Description port number hostname string callback function Source: bridge.js magnet(request, response, next) Returns the magnet link for the given object Parameters: Name Type Description request object response object next function Source: bridge.js resolve(request, response, next) Accepts a body containing a magnet link, resolves the pointer and creates a local object pointer record, then returns it. Clients can follow with a GET /:id to download the object Parameters: Name Type Description request object response object next function Source: bridge.js upload(request, response, next) Queues the object for upload to the network Parameters: Name Type Description request object response object next function Source: bridge.js × Search results Close "},"Database.html":{"id":"Database.html","title":"Class: Database","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Database Database Wraps a MongoDB connection and initializes models new Database(connectionUri, options) Parameters: Name Type Description connectionUri string options object Source: database.js × Search results Close "},"Directory.html":{"id":"Directory.html","title":"Class: Directory","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Directory Directory Serves a single endpoint for retreiving network statistics new Directory(node, options) Parameters: Name Type Description node Node options object Properties Name Type Description enableSSL boolean Use SSL serviceKeyPath string Path to PEM private key certificatePath string Path to PEM certificate authorityChains Array.&lt;string&gt; Path to PEM CA certificates bootstrapService string Address to bootstrap profiles Source: directory.js Methods bootstrap(callback) Bootstraps the peer profiles Parameters: Name Type Description callback function Source: directory.js listen(port, hostname, callback) Start the server on the supplied port and hostname Parameters: Name Type Description port number hostname string callback function Source: directory.js scoreAndPublishAuditReports(callback) Takes all audit reports and reaps them while applying their results to local peer profile reputation score, then publishes the compressed payload to the bootstrap directory Parameters: Name Type Description callback function Source: directory.js × Search results Close "},"KadStorageAdapter.html":{"id":"KadStorageAdapter.html","title":"Class: KadStorageAdapter","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: KadStorageAdapter KadStorageAdapter Wraps the supplied model for a kad/levelup compatible interface new KadStorageAdapter(databaseModel) Parameters: Name Type Description databaseModel object Source: database.js Methods createReadStream() Returns a readable stream of all items Source: database.js Returns: Type ReadableStream del(key, callback) Delete item by key Parameters: Name Type Description key string callback function Source: database.js get(key [, options], callback) Get item by key Parameters: Name Type Argument Description key string options object &lt;optional&gt; callback function Source: database.js put(key, value [, options], callback) Put item by key Parameters: Name Type Argument Description key string value object options object &lt;optional&gt; callback function Source: database.js × Search results Close "},"module-orc.html":{"id":"module-orc.html","title":"Module: orc","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Module: orc License: AGPL-3.0 Source: index.js Members &lt;static&gt; Audit Audit Source: index.js &lt;static&gt; Bridge Bridge Source: index.js &lt;static&gt; constants module:orc/constants Source: index.js &lt;static&gt; control Source: index.js See: https://github.com/bookchin/boscar &lt;static&gt; Database Database Source: index.js &lt;static&gt; Directory Directory Source: index.js &lt;static&gt; Node Node Source: index.js &lt;static&gt; Proof Proof Source: index.js &lt;static&gt; Rules Rules Source: index.js &lt;static&gt; Server Server Source: index.js &lt;static&gt; Shards Shards Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; utils module:orc/utils Source: index.js &lt;static&gt; version module:orc/version Source: index.js × Search results Close "},"module-orc_constants.html":{"id":"module-orc_constants.html","title":"Module: orc/constants","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Module: orc/constants Source: constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :number Number of bytes for audit challenge Type: number Source: constants.js &lt;inner, constant&gt; AUDIT_INTERVAL :number Time interval for audit check Type: number Source: constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :number Interval for reaping stale shards Type: number Source: constants.js &lt;inner, constant&gt; CONSIGN_THRESHOLD :number Threshold for consign time Type: number Source: constants.js &lt;inner, constant&gt; HD_KEY_DERIVATION_PATH :string Key derivation path for HD key Type: string Source: constants.js &lt;inner, constant&gt; MAX_NODE_INDEX :number Maximum node index Type: number Source: constants.js &lt;inner, constant&gt; NUM_CHALLENGES :number Total challenges to generate per object Type: number Source: constants.js &lt;inner, constant&gt; REAPER_GRACE :number Grace period beyond score interval Type: number Source: constants.js &lt;inner, constant&gt; SCORE_INTERVAL :number Time to score for reputation Type: number Source: constants.js &lt;inner, constant&gt; TOKEN_EXPIRE :number Reject data token after time Type: number Source: constants.js × Search results Close "},"module-orc_utils.html":{"id":"module-orc_utils.html","title":"Module: orc/utils","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Module: orc/utils Source: utils.js Methods &lt;static&gt; createCipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: utils.js Returns: Type object &lt;static&gt; createComplexKeyFromSeed(seed64) Returns a HD key object using corrent key derivation path using the given seed Parameters: Name Type Description seed64 buffer 64 byte seed for generating key Source: utils.js Returns: Type HDKey &lt;static&gt; createDecipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: utils.js Returns: Type object &lt;static&gt; createShardDownloader(farmer, hash, token [, agent]) Returns a request object for downloading a shard from a farmer Parameters: Name Type Argument Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token agent Agent &lt;optional&gt; Source: utils.js Returns: Type https.ClientRequest &lt;static&gt; createShardUploader(farmer, hash, token [, agent]) Returns a request object for uploading a shard to a farmer Parameters: Name Type Argument Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token agent Agent &lt;optional&gt; Source: utils.js Returns: Type https.ClientRequest &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact array Properties Name Type Description 0 string Node identity key 1 object Properties Name Type Description hostname string port string protocol string Source: utils.js Returns: Type string &lt;static&gt; getErasureParameters(n) Returns the appropriate shard size, number of shards, and number of parity shards for RS encoding/decoding provided the total number of bytes of the complete content Parameters: Name Type Description n number Number of bytes in data Source: utils.js Returns: Type object &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number number Source: utils.js Returns: Type number &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version string The semver tag from the contact Source: utils.js Returns: Type boolean &lt;static&gt; isHexaString(a) Determines if a value is hexadecimal string Parameters: Name Type Description a * The value to be tested Source: utils.js Returns: Type boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact array The contact information for a given peer loopback boolean Allows contacts that are localhost Source: utils.js Returns: Type boolean &lt;static&gt; isValidHDNodeKey(hdKey) Checks if the supplied HD key is valid (base58 encoded) and proper length Parameters: Name Type Description hdKey string The HD key in base 58 encoding Source: utils.js Returns: isValidHDKey Type boolean &lt;static&gt; isValidNodeIndex(hdIndex) Checks if the input is a non-hardened HD key index Parameters: Name Type Description hdIndex number The HD key index Source: utils.js Returns: isValidHDKeyIndex Type boolean &lt;static&gt; rmd160(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: utils.js Returns: Type buffer &lt;static&gt; rmd160sha256(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: utils.js Returns: Type buffer &lt;static&gt; sha256(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: utils.js Returns: Type buffer × Search results Close "},"module-orc_version.html":{"id":"module-orc_version.html","title":"Module: orc/version","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Module: orc/version Source: version.js Members &lt;inner, constant&gt; protocol :string The supported protocol version Type: string Source: version.js &lt;inner, constant&gt; software :string The current software version Type: string Source: version.js Methods &lt;static&gt; toString() Returns human readable string of versions Source: version.js Returns: Type string × Search results Close "},"Node.html":{"id":"Node.html","title":"Class: Node","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Node Node Extends Kademlia with Orc protocol rules new Node(options) Parameters: Name Type Description options object Properties Name Type Argument Description privateExtendedKey string HD extended private key logger object &lt;optional&gt; Bunyan compatible logger transport Transport &lt;optional&gt; database Database shards Shards keyDerivationIndex number &lt;optional&gt; HD derivation index License: AGPL-3.0 Source: node.js Methods auditRemoteShards(peer, audits, callback) Sends the series of hash/challenge pairs to the remote node to request proof-of-storage Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact audits Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard to prove challenge string Challenge string to prepend to shard callback Node~auditRemoteShardsCallback Source: node.js authorizeConsignment(peer, hashes, callback) Requests authorization tokens to push file shard(s) to another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to push callback Node~authorizeConsignmentCallback Source: node.js authorizeRetrieval(peer, hashes, callback) Requests authorization tokens to pull file shard(s) from another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to pull callback Node~authorizeRetrievalCallback Source: node.js claimFarmerCapacity(peer, descriptor, callback) Claims capacity from a farming node, given a valid contract Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact descriptor object Contract descriptor callback Node~claimFarmerCapacityCallback Source: node.js createShardMirror(source, target, callback) Requests the source node to MIRROR a shard to the supplied destination Parameters: Name Type Description source array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact target object Properties Name Type Description destination array - Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hash string Hash of the shard to mirror token string Authorization token to PUSH shard callback Node~createShardMirrorCallback Source: node.js identifyService(url, callback) Sends a GET request to the URI and parses the result as a valid contact object with identity Parameters: Name Type Description url string The URL of the node callback Node~identifyServiceCallback Source: node.js listen() Adds the kademlia rule handlers before calling super#listen() Source: node.js publishCapacityAnnouncement(data, callback) Announces to interested renter nodes that this node has capacity available for renting. Parameters: Name Type Description data number Properties Name Type Description available number Total bytes capacity available allocated number Total bytes capacity allocated callback Node~publishCapacityAnnouncementCallback Source: node.js reportAuditResults(report, callback) Publishes the supplied audit reports to nearest neighbors Parameters: Name Type Description report Array.&lt;array&gt; callback Node~reportAuditResultsCallback Source: node.js requestContractRenewal(peer, contract, callback) Requests that the target peer update their local version of the given contract. Used to extend storage time or terminate storage. Peer will respond with an error or their updated, signed record of the renewal. Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 object Address data for contact contract object The completed shard descriptor contract callback Node~requestContractRenewalCallback Source: node.js subscribeCapacityAnnouncement(callback) Subscribes to capacity announcements for the given topic codes and exposes announcements as a stream. Parameters: Name Type Description callback Node~subscribeCapacityAnnouncementCallback Source: node.js Type Definitions auditRemoteShardsCallback(error, proofs) Parameters: Name Type Description error object | null proofs Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard for corresponding proof proof string compact-merkle-proof Source: node.js authorizeConsignmentCallback(error, consignmentTokens) Parameters: Name Type Description error error | null consignmentTokens Array.&lt;string&gt; Source: node.js authorizeRetrievalCallback(error, retrievalTokens) Parameters: Name Type Description error error | null retrievalTokens Array.&lt;string&gt; Source: node.js claimFarmerCapacityCallback(error, result) Parameters: Name Type Description error error | null result array Properties Name Type Description 0 object Completed contract result 1 string Consignment token Source: node.js createShardMirrorCallback(error) Parameters: Name Type Description error object | null Source: node.js identifyServiceCallback(error, contact) Parameters: Name Type Description error error | null contact array Source: node.js publishCapacityAnnouncementCallback(error) Parameters: Name Type Description error error | null Source: node.js requestContractRenewalCallback(error, contract) Parameters: Name Type Description error error | null contract object See storage-contracts Source: node.js subscribeCapacityAnnouncementCallback(error, capacityStream) Parameters: Name Type Description error error | null capacityStream ReadableStream Source: node.js × Search results Close "},"Proof.html":{"id":"Proof.html","title":"Class: Proof","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Proof Proof Provides interface for proving possession of a file for an AuditStream new Proof(merkleLeaves, hexChallenge) Parameters: Name Type Description merkleLeaves Array.&lt;string&gt; Bottom leaves of the audit merkle tree hexChallenge string | buffer The challenge data in hex to prepend to shard Source: proof.js Methods &lt;static&gt; verify(proof, root, depth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description proof * Compact proof result root string Merkle tree root from audit leaves depth number Depth of the merkle tree Source: proof.js Returns: Type Array.&lt;string&gt; getProofResult() Returns the generated proof structure Source: proof.js Returns: Type array × Search results Close "},"Rules.html":{"id":"Rules.html","title":"Class: Rules","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Rules Rules Represents Orc protocol handlers new Rules(node) Constructs a Orc rules instance in the context of a Orc node Parameters: Name Type Description node Node Source: rules.js Methods audit(request, response) Upon receipt of a AUDIT message, the node must look up the contract that is associated with each hash-challenge pair in the payload, prepend the challenge to the shard data, and caclulate the resulting hash, formatted as a compact proof. See compact-proofs. Parameters: Name Type Description request object response object Source: rules.js claim(request, response) Upon receipt of an `CLAIM` message, nodes must validate the descriptor, then ensure that there is enough available space for the shard. If both checks succeed, then the descriptor is signed and returned along with a consignment token so the initiating renter can immediately upload the data. These messages are generally sent based on information collected when subscribed to farmer capacity publications. Parameters: Name Type Description request object response object Source: rules.js consign(request, response) Upon receipt of a CONSIGN message, the node must verify that it has a valid storage allocation and contract for the supplied hash and identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: rules.js mirror(request, response) Upon receipt of a MIRROR message, the node must verify that it is in possesion of the shard on behalf of the identity or the message originator. If so, given the token-hash pair, it must attempt to upload it's copy of the shard to the target to establish a mirror. Parameters: Name Type Description request object response object Source: rules.js renew(request, response) Upon receipt of a RENEW message, the recipient farmer must extend or terminate it's contract based on the new terms supplied by the renter. If the renewal descriptor is valid and complete, the farmer must store the updated version after signing and respond back to the originator with the version containing the updated signature. Parameters: Name Type Description request object response object Source: rules.js report(request, response, next) Handles the receipt of a REPORT message containing audit results for N total peers Parameters: Name Type Description request object response object next function Source: rules.js retrieve(request, response) Upon receipt of a RETRIEVE message, the node must verify that it is in possession of the shard on behalf of the identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: rules.js × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Server Server Creates a shard server for sending and receiving consigned file shards new Server(options) Parameters: Name Type Description options object Properties Name Type Argument Default Description identity string Node identity key database Database shards Shards tokenTtl number &lt;optional&gt; 1800000 Expire unused token Source: server.js Methods accept(token, filehash, contact) Begin accepting data for the given file hash and token Parameters: Name Type Description token string The authorization token created for transfer filehash string The shard hash to allow for the token contact array Contact that negotiated the token Source: server.js authorize(token, hash) Validates the given token Parameters: Name Type Description token string hash string Source: server.js Returns: Type object download(req, res) Pumps the data through to the client Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token string The authorization token created for transfer Source: server.js upload(req, req) Receives the data stream and writes it to storage Parameters: Name Type Description req http.IncomingMessage req http.ServerResponse Source: server.js Events error Triggered when a error occurs Parameters: Name Type Description error error Source: server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: server.js × Search results Close "},"Shards.html":{"id":"Shards.html","title":"Class: Shards","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Shards Shards Convenience wrapper for storing shards scoped to a directory new Shards(directory) Parameters: Name Type Description directory string Directory path to shard storage Source: shards.js Methods createReadStream(key, callback) Wraps read stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createReadStreamCallback Source: shards.js createWriteStream(key, callback) Wraps write stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createWriteStreamCallback Source: shards.js exists(key, callback) Check if the shard exists Parameters: Name Type Description key string callback Shards~existsCallback Source: shards.js size(callback) Get used space and remaining allocation Parameters: Name Type Description callback Shards~sizeCallback Source: shards.js unlink(key, callback) Unlink the shard from the file system Parameters: Name Type Description key string callback Shards~unlinkCallback Source: shards.js Type Definitions createReadStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: shards.js createWriteStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: shards.js existsCallback(error, exists) Parameters: Name Type Description error error | null exists boolean Source: shards.js unlinkCallback(error) Parameters: Name Type Description error error | null Source: shards.js × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Class: Transport Transport Represents the Orc-specific HTTP(S) transport new Transport(options) Contructs a Orc transport adapter Parameters: Name Type Description options object Source: transport.js Events download Emitted when a download request is received Parameters: Name Type Description request object response object Source: transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: transport.js × Search results Close "},"tutorial-config.html":{"id":"tutorial-config.html","title":"Tutorial: Configuration Guide","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Configuration Guide This guide will show you how to get started with running orc! An Orc node requires a configuration file to get up and running. The path to this file is given to orc when starting a node. orc --config path/to/orc.configIf a configuration file is not supplied, a minimal default configuration is automatically created and used, which will generate a private extended key, self-signed SSL certificate, and storage for shards, contracts, and directory information. All of this data will be created and stored in $HOME/.config/orc, yielding a directory structure like this: +- ~/.config/orc + - x_private_key + - onion_key + - config + - service_key.pem + - certificate.pem + - /shards + - ...The locations of all of these files is defined in your configuration file. Below is a complete sample config in INI format (though JSON is also supported). Comments are inline to describe each property. Default Configuration; ; Orc Sample Configuration ; ; Path to private extended key file to use for master identity. ; Generate one with: ; ; orctool generate-key --extended &gt;&gt; x_private_key ; PrivateExtendedKeyPath = /home/bookchin/.config/orc/x_private_key ; The index for deriving this child node's identity. This allows you to run ; multiple nodes with the same private extended key. If your private extended ; key was converted from an old non-hierarchically-deterministic private key, ; you must set the value to -1 ChildDerivationIndex = 0 ; Set the directory to store database and the port that MongoDB should use ; to accept connections MongoDBDataDirectory = /home/bookchin/.config/orc/data MongoDBPort = 37017 ; Set the base directory (parent) for where the shards folder will be ; placed. The shards stores other nodes data shards, so be sure you set ; this to where you intend to store farmed shards. ShardStorageBaseDir = /home/bookchin/.config/orc ; Define the maximum size you wish to allocate for farming shards. This can be ; increased later, but decreasing it will not delete existing data. ShardStorageMaxAllocation = 0GB ; Set the base directory (parent) for where the directory.db folder will be ; placed. The directory.db holds key-value pairs for the distributed hash ; table, which serve various purposes such as reputation data on other peers. ; In addition, if the directory profile is enabled, use the supplied hostname, ; port, and optional SSL configuration to serve a public (clearnet) statistics ; API. DirectoryEnabled = 1 DirectoryPort = 4446 DirectoryHostname = 127.0.0.1 DirectoryUseSSL = 0 DirectoryServiceKeyPath: /home/bookchin/.config/orc/directory_key.pem DirectoryCertificatePath: /home/bookchin/.config/orc/directory_cert.pem ;DirectoryAuthorityChains[] = /home/bookchin/.config/fullchain.pem DirectoryBootstrapService = https://orcucqxc54fkhupb.onion:443 ; Paths to this node's SSL key and certificat. If you don't have one, you can ; generate one with the following: ; ; orctool generate-cert | csplit - 28 ; mv xx00 service_key.pem ; mv xx01 certificate.pem ; TransportServiceKeyPath = /home/bookchin/.config/orc/service_key.pem TransportCertificatePath = /home/bookchin/.config/orc/certificate.pem ; Path to this node's RSA1024 Tor hidden service private key. If this path does ; not exist, it will be automatically generated for you. If you'd like to ; generate one yourself, you can use: ; ; orctool generate-onion &gt;&gt; onion_key ; OnionServicePrivateKeyPath = /home/bookchin/.config/orc/onion_key ; Set the public port number at which your node will be reachable to others. ; This should be the port you forwarded. PublicPort = 443 ; Set the local port to bind the node service. ListenPort = 4443 ; Enables bandwidth metering and hibernation mode. When the property ; BandwidthAccountingEnabled is 1, we will enter low-bandwidth mode if the we ; exceed BandwidthAccountingMax within the period defined by the property ; BandwidthAccountingReset until the interval is finished BandwidthAccountingEnabled = 0 BandwidthAccountingMax = 5GB BandwidthAccountingReset = 24HR ; Set to 1 for more detailed logging, which is useful for debugging VerboseLoggingEnabled = 1 ; Set the ControlPort to bind the control interface. Used for controlling the ; node from other applications. Be sure that ControlHostname is kept set to ; a loopback address, unless you have taken other measures to prevent others ; from controlling your node. ControlPort = 4444 ControlHostname = 127.0.0.1 ; Add a map of network bootstrap nodes to this section to use for discovering ; other peers. Default configuration should come with a list of known and ; trusted contacts. Formatted as &quot;https://{onion}:{port}&quot;. NetworkBootstrapNodes[] = https://orcjd7xgshpovm6i.onion:443 NetworkBootstrapNodes[] = https://orcjfg52ty6ljv54.onion:443 NetworkBootstrapNodes[] = https://orce4nqoa6muz3gt.onion:443 NetworkBootstrapNodes[] = https://orcwfkilxjxo63mr.onion:443 ; Perform as self test for service availability every so often. If the check ; fails, re-establish service and switch to new Tor circuits ServiceAvailabilityCheckInterval = 10M ; When enabled via &quot;renter&quot; profile, bind a local bridge server that allows for ; GET and POST HTTP requests for uploading and downloading files from the ; network. The bridge will handle encryption and erasure coding for you. ; Optionally, protect the local bridge access using HTTP Basic Authentication ; credentials defined here. BridgeEnabled = 1 BridgeHostname = 127.0.0.1 BridgePort = 4445 BridgeUseSSL = 0 BridgeServiceKeyPath = /home/bookchin/.config/orc/service_key.pem BridgeCertificatePath = /home/bookchin/.config/orc/certificate.pem BridgeAuthorityChains[] = /home/bookchin/.config/orc/fullchain.pem BridgeAuthenticationEnabled = 0 BridgeAuthenticationUser = orc BridgeAuthenticationPassword = 1b5d3daa16b3343560bcf0377547b1c0 BridgeTempStagingBaseDir = /home/bookchin/.config/orc/__bridge.staging ; How often we should scan contract database to reap expired shards it is ; storing. ShardReaperInterval = 24HR ; How often we should publish a capacity announcement to neighboring nodes. CapacityAnnounceInterval = 15M × Search results Close "},"tutorial-directory_.html":{"id":"tutorial-directory_.html","title":"Tutorial: Running a Directory","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Running a Directory Directories are &quot;passive&quot; ORC nodes that hang around the network and relay publications for farmers and renters. During this process, directories maintain a cache of all the farmers it has seen, their service contact information and the available and allocated capacity they have. Using this cache, directories expose an API (optionally over the clearnet) to aid applications in gaining valuable insight into the state of the network. The ORC Project maintains a public directory node with an API exposed at https://directory.orc.network. Feel free to use it or run your own! If you wish to run your own, this guide will show you how to properly configure your node. This will only cover configuration specific to running a directory, so for more information be sure to check out the Configuration Guide. Configure Directory APIWhen the directory profile is enabled, use the supplied hostname, port, and optional SSL configuration to serve a public (clearnet) statistics API. DirectoryPort = 4446 DirectoryHostname = 127.0.0.1 DirectoryUseSSL = 0 DirectoryServiceKeyPath: /home/bookchin/.config/orc/directory_key.pem DirectoryCertificatePath: /home/bookchin/.config/orc/directory_cert.pem DirectoryAuthorityChains[] = /home/bookchin/.config/fullchain.pem × Search results Close "},"tutorial-install.html":{"id":"tutorial-install.html","title":"Tutorial: Manual Installation","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Manual Installation Make sure you have the following prerequisites installed: Tor Git Node.js LTS + NPM (6.10.x) Python 2.7 GCC/G++/Make Node.js + NPMGNU+Linux &amp; Mac OSXwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashClose your shell and open an new one. Now that you can call the nvm program, install Node.js (which comes with NPM): nvm install --ltsBuild DependenciesGNU+LinuxDebian / Ubuntu / Mint / Trisquel / and Friends apt install git python build-essentialRed Hat / Fedora / CentOS yum groupinstall 'Development Tools'You might also find yourself lacking a C++11 compiler - see this. Mac OSXxcode-select --installWindowsRun as administrator in PowerShell or cmd: npm install -g windows-build-toolsDaemon + Utilities CLIThis package exposes 3 command line programs: orc, orcd, and orctool. To install these, use the --global flag. npm install -g @orcproject/orcOn Windows, things are different - and a little weird. Instead, do the following. git clone https://github.com/orproject/orc cd orc npm install --ignore-scripts npm install granax npm remove electron-prebuilt-compile npm install electron-prebuilt-compile npm link npm run start-win Note that some native dependencies do not work on Windows and will fallback to JavaScript implementations. This will impact performance. You should run GNU+Linux. :) Core LibraryThis package exposes a module providing a complete implementation of the protocol. To use it in your project, from your project's root directory, install as a dependency. npm install @orcproject/orc --saveThen you can require the library with: const orc = require('@orcproject/orc/lib');Building PackagesTo build a distributable package for your platform, clone the repository and follow the steps above for your platform, then run: npm run make # linux/osx npm run make-win # windowsOn Mac OS, you'll want to remove this package before building: npm remove dtrace-provider × Search results Close "},"tutorial-providing.html":{"id":"tutorial-providing.html","title":"Tutorial: Providing Capacity","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Providing Capacity It's easy to configure ORC for providing. Check out the Configuration Guide for an overview of all configuration properties - this guide only covers what is needed for providing. This guide also assumes you have properly installed ORC via the provided Docker image or have completed the Manual Installation guide. Note that ORC will provide 5GB to the network without any modification. Allocate Storage CapacitySet the base directory (parent) for where the shards folder will be placed. The shards stores other nodes data shards, so be sure you set this to where you intend to store shards. ShardStorageBaseDir = /home/bookchin/.config/orcDefine the maximum size you wish to allocate for shards. This can be increased later, but decreasing it will not delete existing data. ShardStorageMaxAllocation = 5GBFine Tune Provider BehaviorHow often a provider profile should scan contract database to reap expired shards it is storing. ShardReaperInterval = 24HRHow often a provider profile should publish a capacity announcement to it's neighboring nodes. CapacityAnnounceInterval = 15M × Search results Close "},"tutorial-transfers.html":{"id":"tutorial-transfers.html","title":"Tutorial: Uploading and Downloading","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Uploading and Downloading Managing your objects (files) on the ORC network is easy! This guide will show you how to configure your node to expose a simple REST API that applications can use to upload, download, delete, and list objects you have stored in the network. BridgeEnabledSet this property to 1 to enable the local API. BridgeHostnameSet this property to bind the service to an hostname or IP address. It's important to use a loopback interface or LAN IP otherwise an attacker may be able to upload and download your objects! Best to use 127.0.0.1 which is the default. BridgePortSet this property to instruct the local bridge service to bind to the given port. Defaults to 4445. BridgeTempStagingBaseDirSet this property to instruct the local bridge service where to hold temporary data while objects are being uploaded to the network. Safe to leave as the default, which is ~/.config/orc/__bridge.staging. List Objects StoredYou can get a JSON list of your objects stored in the network by sending a request to GET /. Example: $ curl http://127.0.0.1:4445 | jq [ { &quot;id&quot;: &quot;d049bff2-21b5-4f2f-bac3-efb3832a5afb&quot;, &quot;name&quot;: &quot;README.md&quot;, &quot;encoding&quot;: &quot;7bit&quot;, &quot;mimetype&quot;: &quot;application/octet-stream&quot;, &quot;hash&quot;: &quot;877167565af0376f2fddb170ad0483f91e9b932d72052720ae15efeb8ec2b010&quot;, &quot;size&quot;: 3229, &quot;status&quot;: &quot;finished&quot;, &quot;shards&quot;: [ { &quot;index&quot;: 0, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;6ee50b070fb8ce1fcd42814d18ee10f0615c235c&quot;, {...} ], &quot;contract&quot;: {...} }, { &quot;index&quot;: 1, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;e34d507bf40171f1471dd1d7f41323439e36fe37&quot;, {...} ], &quot;contract&quot;: {...} }, { &quot;index&quot;: 2, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;cc31602c67a35a26d23d93d62bef0d6d09c89e0d&quot;, {...} ], &quot;contract&quot;: {...} ] } ]Upload ObjectsYou can upload a file to the network my sending a multipart/form-upload request to POST /. This works the same as if using a &lt;input type=&quot;file&quot;/&gt; on a web page. You can also add policy fields to specify access policies as defined in IMP-0010. Example: $ curl -F &quot;file=@README.md;filename=README.md&quot; http://127.0.0.1:4445 | jq { &quot;id&quot;: &quot;d049bff2-21b5-4f2f-bac3-efb3832a5afb&quot;, &quot;name&quot;: &quot;README.md&quot;, &quot;encoding&quot;: &quot;7bit&quot;, &quot;mimetype&quot;: &quot;application/octet-stream&quot;, &quot;hash&quot;: &quot;877167565af0376f2fddb170ad0483f91e9b932d72052720ae15efeb8ec2b010&quot;, &quot;size&quot;: 3229, &quot;status&quot;: &quot;finished&quot;, &quot;shards&quot;: [ { &quot;index&quot;: 0, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;6ee50b070fb8ce1fcd42814d18ee10f0615c235c&quot;, {...} ], &quot;contract&quot;: {...} }, { &quot;index&quot;: 1, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;e34d507bf40171f1471dd1d7f41323439e36fe37&quot;, {...} ], &quot;contract&quot;: {...} }, { &quot;index&quot;: 2, &quot;size&quot;: 1616, &quot;audits&quot;: {...}, &quot;service&quot;: [ &quot;cc31602c67a35a26d23d93d62bef0d6d09c89e0d&quot;, {...} ], &quot;contract&quot;: {...} ] }Download ObjectsYou can download a file from the network knowing only the UUID generated by the local bridge service, by sending a GET /{uuid} request. Example: $ curl http://127.0.0.1:4445/d049bff2-21b5-4f2f-bac3-efb3832a5afb &gt;&gt; README.mdSharing ObjectsIf you supplied an appropriate access policy field on upload, you can share a magnet link with others to fetch the object pointer. Example: $ curl http://127.0.0.1:4445/d049bff2-21b5-4f2f-bac3-efb3832a5afb/magnet | xclip -selection clipboardTo fetch an object pointer shared by someone else, you can send the magnet link and get back an object pointer with an ID you can use in the download example: Example: curl -X PUT --data &quot;magnet:?xt=...&quot; http://127.0.0.1:4445Destroy ObjectsYou can destroy an object, nullifying associated contracts, and issuing any final payment to farmers by sending a DELETE /{uuid} request. Example: $ curl -X &quot;DELETE&quot; http://127.0.0.1:4445/d049bff2-21b5-4f2f-bac3-efb3832a5afb × Search results Close "},"tutorial-usage.html":{"id":"tutorial-usage.html","title":"Tutorial: Basic Usage Guide","body":" ORC Modules orcorc/constantsorc/utilsorc/version Classes AuditBridgeDatabaseDirectoryKadStorageAdapterNodeProofRulesServerShardsTransport Events Server#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideRunning a DirectoryManual InstallationProviding CapacityUploading and DownloadingBasic Usage Guide Global AuditReportNetworkBlobObjectPointerPeerProfileShardContract Basic Usage Guide The easiest way to get up and running with orc is to spawn a child process from your program and connect to it over the control port. This package exposes a convenience method for doing this. const orc = require('@orcproject/orc/lib'); const { child, controller } = orc(config); // The `config` argument can be either a string path to config file to use or // a JSON dictionary of config properties. See configuration documentaion. child.stdout.pipe(process.stdout); // Pipe log out put to stdout controller.on('ready', () =&gt; { controller.invoke('ping', [contact], console.log); // Ping a contact });Control InterfaceYou can run orc standalone and control it from any other application over its TCP control interface. See the Resources section below to read up on the control protocol to implement it in the language of your choice. If using Node.js, you can use the client bundled in this package. const orc = require('@orcproject/orc'); const controller = new orc.control.Client(); controller.on('ready', () =&gt; { controller.invoke('ping', [contact], (err) =&gt; { /* handle result */ }); }); controller.connect(port);If you wish to control your orc node from another language, simply connect to the control port over a TCP socket and use the BOSCAR protocol to send RPC messages to the node. The methods and argument signatures map directly to the orc.Node API describe in the documentation. See Resources below. Direct ImplementationSince orc exposes all of the internals used to implement it, you can use the same classes to directly implement your own ORC node within your project. Just import the package and construct a node instance with options. const orc = require('@orcproject/orc'); const node = new orc.Node(options); node.listen(8443); node.join(['known_node_id', { /* contact data */ }]);Consult the documentation for a complete reference of the API exposed from the Node object. Further documentation on usage can be found by reviewing the end-to-end test suite in test/node.e2e.js. Note that using this package as a library provides a very low level interface for the ORC protocol and is not intended for casual integration with the ORC network. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
